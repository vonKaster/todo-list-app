{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * vue-meta v2.4.0\n * (c) 2020\n * - Declan de Wet\n * - SÃ©bastien Chopin (@Atinux)\n * - Pim (@pimlie)\n * - All the amazing contributors\n * @license MIT\n */\n\nimport deepmerge from 'deepmerge';\nvar version = \"2.4.0\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\n/**\n * checks if passed argument is an array\n * @param  {any}  arg - the object to check\n * @return {Boolean} - true if `arg` is an array\n */\nfunction isArray(arg) {\n  return Array.isArray(arg);\n}\nfunction isUndefined(arg) {\n  return typeof arg === 'undefined';\n}\nfunction isObject(arg) {\n  return _typeof(arg) === 'object';\n}\nfunction isPureObject(arg) {\n  return _typeof(arg) === 'object' && arg !== null;\n}\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nfunction hasGlobalWindowFn() {\n  try {\n    return !isUndefined(window);\n  } catch (e) {\n    return false;\n  }\n}\nvar hasGlobalWindow = hasGlobalWindowFn();\nvar _global = hasGlobalWindow ? window : global;\nvar console = _global.console || {};\nfunction warn(str) {\n  /* istanbul ignore next */\n  if (!console || !console.warn) {\n    return;\n  }\n  console.warn(str);\n}\nvar showWarningNotSupported = function showWarningNotSupported() {\n  return warn('This vue app/component has no vue-meta configuration');\n};\n\n/**\n * These are constant variables used throughout the application.\n */\n// set some sane defaults\nvar defaultInfo = {\n  title: undefined,\n  titleChunk: '',\n  titleTemplate: '%s',\n  htmlAttrs: {},\n  bodyAttrs: {},\n  headAttrs: {},\n  base: [],\n  link: [],\n  meta: [],\n  style: [],\n  script: [],\n  noscript: [],\n  __dangerouslyDisableSanitizers: [],\n  __dangerouslyDisableSanitizersByTagID: {}\n};\nvar rootConfigKey = '_vueMeta'; // This is the name of the component option that contains all the information that\n// gets converted to the various meta tags & attributes for the page.\n\nvar keyName = 'metaInfo'; // This is the attribute vue-meta arguments on elements to know which it should\n// manage and which it should ignore.\n\nvar attribute = 'data-vue-meta'; // This is the attribute that goes on the `html` tag to inform `vue-meta`\n// that the server has already generated the meta tags for the initial render.\n\nvar ssrAttribute = 'data-vue-meta-server-rendered'; // This is the property that tells vue-meta to overwrite (instead of append)\n// an item in a tag list. For example, if you have two `meta` tag list items\n// that both have `vmid` of \"description\", then vue-meta will overwrite the\n// shallowest one with the deepest one.\n\nvar tagIDKeyName = 'vmid'; // This is the key name for possible meta templates\n\nvar metaTemplateKeyName = 'template'; // This is the key name for the content-holding property\n\nvar contentKeyName = 'content'; // The id used for the ssr app\n\nvar ssrAppId = 'ssr'; // How long meta update\n\nvar debounceWait = 10; // How long meta update\n\nvar waitOnDestroyed = true;\nvar defaultOptions = {\n  keyName: keyName,\n  attribute: attribute,\n  ssrAttribute: ssrAttribute,\n  tagIDKeyName: tagIDKeyName,\n  contentKeyName: contentKeyName,\n  metaTemplateKeyName: metaTemplateKeyName,\n  waitOnDestroyed: waitOnDestroyed,\n  debounceWait: debounceWait,\n  ssrAppId: ssrAppId\n}; // might be a bit ugly, but minimizes the browser bundles a bit\n\nvar defaultInfoKeys = Object.keys(defaultInfo); // The metaInfo property keys which are used to disable escaping\n\nvar disableOptionKeys = [defaultInfoKeys[12], defaultInfoKeys[13]]; // List of metaInfo property keys which are configuration options (and dont generate html)\n\nvar metaInfoOptionKeys = [defaultInfoKeys[1], defaultInfoKeys[2], 'changed'].concat(disableOptionKeys); // List of metaInfo property keys which only generates attributes and no tags\n\nvar metaInfoAttributeKeys = [defaultInfoKeys[3], defaultInfoKeys[4], defaultInfoKeys[5]]; // HTML elements which support the onload event\n\nvar tagsSupportingOnload = ['link', 'style', 'script']; // HTML elements which dont have a head tag (shortened to our needs)\n// see: https://www.w3.org/TR/html52/document-metadata.html\n\nvar tagsWithoutEndTag = ['base', 'meta', 'link']; // HTML elements which can have inner content (shortened to our needs)\n\nvar tagsWithInnerContent = ['noscript', 'script', 'style']; // Attributes which are inserted as childNodes instead of HTMLAttribute\n\nvar tagAttributeAsInnerContent = ['innerHTML', 'cssText', 'json'];\nvar tagProperties = ['once', 'skip', 'template']; // Attributes which should be added with data- prefix\n\nvar commonDataAttributes = ['body', 'pbody']; // from: https://github.com/kangax/html-minifier/blob/gh-pages/src/htmlminifier.js#L202\n\nvar booleanHtmlAttributes = ['allowfullscreen', 'amp', 'amp-boilerplate', 'async', 'autofocus', 'autoplay', 'checked', 'compact', 'controls', 'declare', 'default', 'defaultchecked', 'defaultmuted', 'defaultselected', 'defer', 'disabled', 'enabled', 'formnovalidate', 'hidden', 'indeterminate', 'inert', 'ismap', 'itemscope', 'loop', 'multiple', 'muted', 'nohref', 'noresize', 'noshade', 'novalidate', 'nowrap', 'open', 'pauseonexit', 'readonly', 'required', 'reversed', 'scoped', 'seamless', 'selected', 'sortable', 'truespeed', 'typemustmatch', 'visible'];\nvar batchId = null;\nfunction triggerUpdate(_ref, rootVm, hookName) {\n  var debounceWait = _ref.debounceWait;\n\n  // if an update was triggered during initialization or when an update was triggered by the\n  // metaInfo watcher, set initialized to null\n  // then we keep falsy value but know we need to run a triggerUpdate after initialization\n  if (!rootVm[rootConfigKey].initialized && (rootVm[rootConfigKey].initializing || hookName === 'watcher')) {\n    rootVm[rootConfigKey].initialized = null;\n  }\n  if (rootVm[rootConfigKey].initialized && !rootVm[rootConfigKey].pausing) {\n    // batch potential DOM updates to prevent extraneous re-rendering\n    // eslint-disable-next-line no-void\n    batchUpdate(function () {\n      return void rootVm.$meta().refresh();\n    }, debounceWait);\n  }\n}\n/**\n * Performs a batched update.\n *\n * @param  {(null|Number)} id - the ID of this update\n * @param  {Function} callback - the update to perform\n * @return {Number} id - a new ID\n */\n\nfunction batchUpdate(callback, timeout) {\n  timeout = timeout === undefined ? 10 : timeout;\n  if (!timeout) {\n    callback();\n    return;\n  }\n  clearTimeout(batchId);\n  batchId = setTimeout(function () {\n    callback();\n  }, timeout);\n  return batchId;\n}\n\n/*\n * To reduce build size, this file provides simple polyfills without\n * overly excessive type checking and without modifying\n * the global Array.prototype\n * The polyfills are automatically removed in the commonjs build\n * Also, only files in client/ & shared/ should use these functions\n * files in server/ still use normal js function\n */\nfunction find(array, predicate, thisArg) {\n  if (!Array.prototype.find) {\n    // idx needs to be a Number, for..in returns string\n    for (var idx = 0; idx < array.length; idx++) {\n      if (predicate.call(thisArg, array[idx], idx, array)) {\n        return array[idx];\n      }\n    }\n    return;\n  }\n  return array.find(predicate, thisArg);\n}\nfunction findIndex(array, predicate, thisArg) {\n  if (!Array.prototype.findIndex) {\n    // idx needs to be a Number, for..in returns string\n    for (var idx = 0; idx < array.length; idx++) {\n      if (predicate.call(thisArg, array[idx], idx, array)) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n  return array.findIndex(predicate, thisArg);\n}\nfunction toArray(arg) {\n  if (!Array.from) {\n    return Array.prototype.slice.call(arg);\n  }\n  return Array.from(arg);\n}\nfunction includes(array, value) {\n  if (!Array.prototype.includes) {\n    for (var idx in array) {\n      if (array[idx] === value) {\n        return true;\n      }\n    }\n    return false;\n  }\n  return array.includes(value);\n}\nvar querySelector = function querySelector(arg, el) {\n  return (el || document).querySelectorAll(arg);\n};\nfunction getTag(tags, tag) {\n  if (!tags[tag]) {\n    tags[tag] = document.getElementsByTagName(tag)[0];\n  }\n  return tags[tag];\n}\nfunction getElementsKey(_ref) {\n  var body = _ref.body,\n    pbody = _ref.pbody;\n  return body ? 'body' : pbody ? 'pbody' : 'head';\n}\nfunction queryElements(parentNode, _ref2, attributes) {\n  var appId = _ref2.appId,\n    attribute = _ref2.attribute,\n    type = _ref2.type,\n    tagIDKeyName = _ref2.tagIDKeyName;\n  attributes = attributes || {};\n  var queries = [\"\".concat(type, \"[\").concat(attribute, \"=\\\"\").concat(appId, \"\\\"]\"), \"\".concat(type, \"[data-\").concat(tagIDKeyName, \"]\")].map(function (query) {\n    for (var key in attributes) {\n      var val = attributes[key];\n      var attributeValue = val && val !== true ? \"=\\\"\".concat(val, \"\\\"\") : '';\n      query += \"[data-\".concat(key).concat(attributeValue, \"]\");\n    }\n    return query;\n  });\n  return toArray(querySelector(queries.join(', '), parentNode));\n}\nfunction removeElementsByAppId(_ref3, appId) {\n  var attribute = _ref3.attribute;\n  toArray(querySelector(\"[\".concat(attribute, \"=\\\"\").concat(appId, \"\\\"]\"))).map(function (el) {\n    return el.remove();\n  });\n}\nfunction removeAttribute(el, attributeName) {\n  el.removeAttribute(attributeName);\n}\nfunction hasMetaInfo(vm) {\n  vm = vm || this;\n  return vm && (vm[rootConfigKey] === true || isObject(vm[rootConfigKey]));\n} // a component is in a metaInfo branch when itself has meta info or one of its (grand-)children has\n\nfunction inMetaInfoBranch(vm) {\n  vm = vm || this;\n  return vm && !isUndefined(vm[rootConfigKey]);\n}\nfunction pause(rootVm, refresh) {\n  rootVm[rootConfigKey].pausing = true;\n  return function () {\n    return resume(rootVm, refresh);\n  };\n}\nfunction resume(rootVm, refresh) {\n  rootVm[rootConfigKey].pausing = false;\n  if (refresh || refresh === undefined) {\n    return rootVm.$meta().refresh();\n  }\n}\nfunction addNavGuards(rootVm) {\n  var router = rootVm.$router; // return when nav guards already added or no router exists\n\n  if (rootVm[rootConfigKey].navGuards || !router) {\n    /* istanbul ignore next */\n    return;\n  }\n  rootVm[rootConfigKey].navGuards = true;\n  router.beforeEach(function (to, from, next) {\n    pause(rootVm);\n    next();\n  });\n  router.afterEach(function () {\n    rootVm.$nextTick(function () {\n      var _resume = resume(rootVm),\n        metaInfo = _resume.metaInfo;\n      if (metaInfo && isFunction(metaInfo.afterNavigation)) {\n        metaInfo.afterNavigation(metaInfo);\n      }\n    });\n  });\n}\nvar appId = 1;\nfunction createMixin(Vue, options) {\n  // for which Vue lifecycle hooks should the metaInfo be refreshed\n  var updateOnLifecycleHook = ['activated', 'deactivated', 'beforeMount'];\n  var wasServerRendered = false; // watch for client side component updates\n\n  return {\n    beforeCreate: function beforeCreate() {\n      var _this2 = this;\n      var rootKey = '$root';\n      var $root = this[rootKey];\n      var $options = this.$options;\n      var devtoolsEnabled = Vue.config.devtools;\n      Object.defineProperty(this, '_hasMetaInfo', {\n        configurable: true,\n        get: function get() {\n          // Show deprecation warning once when devtools enabled\n          if (devtoolsEnabled && !$root[rootConfigKey].deprecationWarningShown) {\n            warn('VueMeta DeprecationWarning: _hasMetaInfo has been deprecated and will be removed in a future version. Please use hasMetaInfo(vm) instead');\n            $root[rootConfigKey].deprecationWarningShown = true;\n          }\n          return hasMetaInfo(this);\n        }\n      });\n      if (this === $root) {\n        $root.$once('hook:beforeMount', function () {\n          wasServerRendered = this.$el && this.$el.nodeType === 1 && this.$el.hasAttribute('data-server-rendered'); // In most cases when you have a SSR app it will be the first app thats gonna be\n          // initiated, if we cant detect the data-server-rendered attribute from Vue but we\n          // do see our own ssrAttribute then _assume_ the Vue app with appId 1 is the ssr app\n          // attempted fix for #404 & #562, but we rly need to refactor how we pass appIds from\n          // ssr to the client\n\n          if (!wasServerRendered && $root[rootConfigKey] && $root[rootConfigKey].appId === 1) {\n            var htmlTag = getTag({}, 'html');\n            wasServerRendered = htmlTag && htmlTag.hasAttribute(options.ssrAttribute);\n          }\n        });\n      } // Add a marker to know if it uses metaInfo\n      // _vnode is used to know that it's attached to a real component\n      // useful if we use some mixin to add some meta tags (like nuxt-i18n)\n\n      if (isUndefined($options[options.keyName]) || $options[options.keyName] === null) {\n        return;\n      }\n      if (!$root[rootConfigKey]) {\n        $root[rootConfigKey] = {\n          appId: appId\n        };\n        appId++;\n        if (devtoolsEnabled && $root.$options[options.keyName]) {\n          // use nextTick so the children should be added to $root\n          this.$nextTick(function () {\n            // find the first child that lists fnOptions\n            var child = find($root.$children, function (c) {\n              return c.$vnode && c.$vnode.fnOptions;\n            });\n            if (child && child.$vnode.fnOptions[options.keyName]) {\n              warn(\"VueMeta has detected a possible global mixin which adds a \".concat(options.keyName, \" property to all Vue components on the page. This could cause severe performance issues. If possible, use $meta().addApp to add meta information instead\"));\n            }\n          });\n        }\n      } // to speed up updates we keep track of branches which have a component with vue-meta info defined\n      // if _vueMeta = true it has info, if _vueMeta = false a child has info\n\n      if (!this[rootConfigKey]) {\n        this[rootConfigKey] = true;\n        var parent = this.$parent;\n        while (parent && parent !== $root) {\n          if (isUndefined(parent[rootConfigKey])) {\n            parent[rootConfigKey] = false;\n          }\n          parent = parent.$parent;\n        }\n      } // coerce function-style metaInfo to a computed prop so we can observe\n      // it on creation\n\n      if (isFunction($options[options.keyName])) {\n        $options.computed = $options.computed || {};\n        $options.computed.$metaInfo = $options[options.keyName];\n        if (!this.$isServer) {\n          // if computed $metaInfo exists, watch it for updates & trigger a refresh\n          // when it changes (i.e. automatically handle async actions that affect metaInfo)\n          // credit for this suggestion goes to [SÃ©bastien Chopin](https://github.com/Atinux)\n          this.$on('hook:created', function () {\n            this.$watch('$metaInfo', function () {\n              triggerUpdate(options, this[rootKey], 'watcher');\n            });\n          });\n        }\n      } // force an initial refresh on page load and prevent other lifecycleHooks\n      // to triggerUpdate until this initial refresh is finished\n      // this is to make sure that when a page is opened in an inactive tab which\n      // has throttled rAF/timers we still immediately set the page title\n\n      if (isUndefined($root[rootConfigKey].initialized)) {\n        $root[rootConfigKey].initialized = this.$isServer;\n        if (!$root[rootConfigKey].initialized) {\n          if (!$root[rootConfigKey].initializedSsr) {\n            $root[rootConfigKey].initializedSsr = true;\n            this.$on('hook:beforeMount', function () {\n              var $root = this[rootKey]; // if this Vue-app was server rendered, set the appId to 'ssr'\n              // only one SSR app per page is supported\n\n              if (wasServerRendered) {\n                $root[rootConfigKey].appId = options.ssrAppId;\n              }\n            });\n          } // we use the mounted hook here as on page load\n\n          this.$on('hook:mounted', function () {\n            var $root = this[rootKey];\n            if ($root[rootConfigKey].initialized) {\n              return;\n            } // used in triggerUpdate to check if a change was triggered\n            // during initialization\n\n            $root[rootConfigKey].initializing = true; // refresh meta in nextTick so all child components have loaded\n\n            this.$nextTick(function () {\n              var _$root$$meta$refresh = $root.$meta().refresh(),\n                tags = _$root$$meta$refresh.tags,\n                metaInfo = _$root$$meta$refresh.metaInfo; // After ssr hydration (identifier by tags === false) check\n              // if initialized was set to null in triggerUpdate. That'd mean\n              // that during initilazation changes where triggered which need\n              // to be applied OR a metaInfo watcher was triggered before the\n              // current hook was called\n              // (during initialization all changes are blocked)\n\n              if (tags === false && $root[rootConfigKey].initialized === null) {\n                this.$nextTick(function () {\n                  return triggerUpdate(options, $root, 'init');\n                });\n              }\n              $root[rootConfigKey].initialized = true;\n              delete $root[rootConfigKey].initializing; // add the navigation guards if they havent been added yet\n              // they are needed for the afterNavigation callback\n\n              if (!options.refreshOnceOnNavigation && metaInfo.afterNavigation) {\n                addNavGuards($root);\n              }\n            });\n          }); // add the navigation guards if requested\n\n          if (options.refreshOnceOnNavigation) {\n            addNavGuards($root);\n          }\n        }\n      }\n      this.$on('hook:destroyed', function () {\n        var _this = this;\n\n        // do not trigger refresh:\n        // - when user configured to not wait for transitions on destroyed\n        // - when the component doesnt have a parent\n        // - doesnt have metaInfo defined\n        if (!this.$parent || !hasMetaInfo(this)) {\n          return;\n        }\n        delete this._hasMetaInfo;\n        this.$nextTick(function () {\n          if (!options.waitOnDestroyed || !_this.$el || !_this.$el.offsetParent) {\n            triggerUpdate(options, _this.$root, 'destroyed');\n            return;\n          } // Wait that element is hidden before refreshing meta tags (to support animations)\n\n          var interval = setInterval(function () {\n            if (_this.$el && _this.$el.offsetParent !== null) {\n              /* istanbul ignore next line */\n              return;\n            }\n            clearInterval(interval);\n            triggerUpdate(options, _this.$root, 'destroyed');\n          }, 50);\n        });\n      }); // do not trigger refresh on the server side\n\n      if (this.$isServer) {\n        /* istanbul ignore next */\n        return;\n      } // no need to add this hooks on server side\n\n      updateOnLifecycleHook.forEach(function (lifecycleHook) {\n        _this2.$on(\"hook:\".concat(lifecycleHook), function () {\n          triggerUpdate(options, this[rootKey], lifecycleHook);\n        });\n      });\n    }\n  };\n}\nfunction setOptions(options) {\n  // combine options\n  options = isObject(options) ? options : {}; // The options are set like this so they can\n  // be minified by terser while keeping the\n  // user api intact\n  // terser --mangle-properties keep_quoted=strict\n\n  /* eslint-disable dot-notation */\n\n  return {\n    keyName: options['keyName'] || defaultOptions.keyName,\n    attribute: options['attribute'] || defaultOptions.attribute,\n    ssrAttribute: options['ssrAttribute'] || defaultOptions.ssrAttribute,\n    tagIDKeyName: options['tagIDKeyName'] || defaultOptions.tagIDKeyName,\n    contentKeyName: options['contentKeyName'] || defaultOptions.contentKeyName,\n    metaTemplateKeyName: options['metaTemplateKeyName'] || defaultOptions.metaTemplateKeyName,\n    debounceWait: isUndefined(options['debounceWait']) ? defaultOptions.debounceWait : options['debounceWait'],\n    waitOnDestroyed: isUndefined(options['waitOnDestroyed']) ? defaultOptions.waitOnDestroyed : options['waitOnDestroyed'],\n    ssrAppId: options['ssrAppId'] || defaultOptions.ssrAppId,\n    refreshOnceOnNavigation: !!options['refreshOnceOnNavigation']\n  };\n  /* eslint-enable dot-notation */\n}\n\nfunction getOptions(options) {\n  var optionsCopy = {};\n  for (var key in options) {\n    optionsCopy[key] = options[key];\n  }\n  return optionsCopy;\n}\nfunction ensureIsArray(arg, key) {\n  if (!key || !isObject(arg)) {\n    return isArray(arg) ? arg : [];\n  }\n  if (!isArray(arg[key])) {\n    arg[key] = [];\n  }\n  return arg;\n}\nvar serverSequences = [[/&/g, '&amp;'], [/</g, '&lt;'], [/>/g, '&gt;'], [/\"/g, '&quot;'], [/'/g, '&#x27;']];\nvar clientSequences = [[/&/g, \"&\"], [/</g, \"<\"], [/>/g, \">\"], [/\"/g, \"\\\"\"], [/'/g, \"'\"]]; // sanitizes potentially dangerous characters\n\nfunction escape(info, options, escapeOptions, escapeKeys) {\n  var tagIDKeyName = options.tagIDKeyName;\n  var _escapeOptions$doEsca = escapeOptions.doEscape,\n    doEscape = _escapeOptions$doEsca === void 0 ? function (v) {\n      return v;\n    } : _escapeOptions$doEsca;\n  var escaped = {};\n  for (var key in info) {\n    var value = info[key]; // no need to escape configuration options\n\n    if (includes(metaInfoOptionKeys, key)) {\n      escaped[key] = value;\n      continue;\n    } // do not use destructuring for disableOptionKeys, it increases transpiled size\n    // due to var checks while we are guaranteed the structure of the cb\n\n    var disableKey = disableOptionKeys[0];\n    if (escapeOptions[disableKey] && includes(escapeOptions[disableKey], key)) {\n      // this info[key] doesnt need to escaped if the option is listed in __dangerouslyDisableSanitizers\n      escaped[key] = value;\n      continue;\n    }\n    var tagId = info[tagIDKeyName];\n    if (tagId) {\n      disableKey = disableOptionKeys[1]; // keys which are listed in __dangerouslyDisableSanitizersByTagID for the current vmid do not need to be escaped\n\n      if (escapeOptions[disableKey] && escapeOptions[disableKey][tagId] && includes(escapeOptions[disableKey][tagId], key)) {\n        escaped[key] = value;\n        continue;\n      }\n    }\n    if (isString(value)) {\n      escaped[key] = doEscape(value);\n    } else if (isArray(value)) {\n      escaped[key] = value.map(function (v) {\n        if (isPureObject(v)) {\n          return escape(v, options, escapeOptions, true);\n        }\n        return doEscape(v);\n      });\n    } else if (isPureObject(value)) {\n      escaped[key] = escape(value, options, escapeOptions, true);\n    } else {\n      escaped[key] = value;\n    }\n    if (escapeKeys) {\n      var escapedKey = doEscape(key);\n      if (key !== escapedKey) {\n        escaped[escapedKey] = escaped[key];\n        delete escaped[key];\n      }\n    }\n  }\n  return escaped;\n}\nfunction escapeMetaInfo(options, info, escapeSequences) {\n  escapeSequences = escapeSequences || []; // do not use destructuring for seq, it increases transpiled size\n  // due to var checks while we are guaranteed the structure of the cb\n\n  var escapeOptions = {\n    doEscape: function doEscape(value) {\n      return escapeSequences.reduce(function (val, seq) {\n        return val.replace(seq[0], seq[1]);\n      }, value);\n    }\n  };\n  disableOptionKeys.forEach(function (disableKey, index) {\n    if (index === 0) {\n      ensureIsArray(info, disableKey);\n    } else if (index === 1) {\n      for (var key in info[disableKey]) {\n        ensureIsArray(info[disableKey], key);\n      }\n    }\n    escapeOptions[disableKey] = info[disableKey];\n  }); // begin sanitization\n\n  return escape(info, options, escapeOptions);\n}\nfunction applyTemplate(_ref, headObject, template, chunk) {\n  var component = _ref.component,\n    metaTemplateKeyName = _ref.metaTemplateKeyName,\n    contentKeyName = _ref.contentKeyName;\n  if (template === true || headObject[metaTemplateKeyName] === true) {\n    // abort, template was already applied\n    return false;\n  }\n  if (isUndefined(template) && headObject[metaTemplateKeyName]) {\n    template = headObject[metaTemplateKeyName];\n    headObject[metaTemplateKeyName] = true;\n  } // return early if no template defined\n\n  if (!template) {\n    // cleanup faulty template properties\n    delete headObject[metaTemplateKeyName];\n    return false;\n  }\n  if (isUndefined(chunk)) {\n    chunk = headObject[contentKeyName];\n  }\n  headObject[contentKeyName] = isFunction(template) ? template.call(component, chunk) : template.replace(/%s/g, chunk);\n  return true;\n}\nfunction _arrayMerge(_ref, target, source) {\n  var component = _ref.component,\n    tagIDKeyName = _ref.tagIDKeyName,\n    metaTemplateKeyName = _ref.metaTemplateKeyName,\n    contentKeyName = _ref.contentKeyName;\n  // we concat the arrays without merging objects contained in,\n  // but we check for a `vmid` property on each object in the array\n  // using an O(1) lookup associative array exploit\n  var destination = [];\n  if (!target.length && !source.length) {\n    return destination;\n  }\n  target.forEach(function (targetItem, targetIndex) {\n    // no tagID so no need to check for duplicity\n    if (!targetItem[tagIDKeyName]) {\n      destination.push(targetItem);\n      return;\n    }\n    var sourceIndex = findIndex(source, function (item) {\n      return item[tagIDKeyName] === targetItem[tagIDKeyName];\n    });\n    var sourceItem = source[sourceIndex]; // source doesnt contain any duplicate vmid's, we can keep targetItem\n\n    if (sourceIndex === -1) {\n      destination.push(targetItem);\n      return;\n    } // when sourceItem explictly defines contentKeyName or innerHTML as undefined, its\n    // an indication that we need to skip the default behaviour or child has preference over parent\n    // which means we keep the targetItem and ignore/remove the sourceItem\n\n    if (contentKeyName in sourceItem && sourceItem[contentKeyName] === undefined || 'innerHTML' in sourceItem && sourceItem.innerHTML === undefined) {\n      destination.push(targetItem); // remove current index from source array so its not concatenated to destination below\n\n      source.splice(sourceIndex, 1);\n      return;\n    } // we now know that targetItem is a duplicate and we should ignore it in favor of sourceItem\n    // if source specifies null as content then ignore both the target as the source\n\n    if (sourceItem[contentKeyName] === null || sourceItem.innerHTML === null) {\n      // remove current index from source array so its not concatenated to destination below\n      source.splice(sourceIndex, 1);\n      return;\n    } // now we only need to check if the target has a template to combine it with the source\n\n    var targetTemplate = targetItem[metaTemplateKeyName];\n    if (!targetTemplate) {\n      return;\n    }\n    var sourceTemplate = sourceItem[metaTemplateKeyName];\n    if (!sourceTemplate) {\n      // use parent template and child content\n      applyTemplate({\n        component: component,\n        metaTemplateKeyName: metaTemplateKeyName,\n        contentKeyName: contentKeyName\n      }, sourceItem, targetTemplate); // set template to true to indicate template was already applied\n\n      sourceItem.template = true;\n      return;\n    }\n    if (!sourceItem[contentKeyName]) {\n      // use parent content and child template\n      applyTemplate({\n        component: component,\n        metaTemplateKeyName: metaTemplateKeyName,\n        contentKeyName: contentKeyName\n      }, sourceItem, undefined, targetItem[contentKeyName]);\n    }\n  });\n  return destination.concat(source);\n}\nvar warningShown = false;\nfunction merge(target, source, options) {\n  options = options || {}; // remove properties explicitly set to false so child components can\n  // optionally _not_ overwrite the parents content\n  // (for array properties this is checked in arrayMerge)\n\n  if (source.title === undefined) {\n    delete source.title;\n  }\n  metaInfoAttributeKeys.forEach(function (attrKey) {\n    if (!source[attrKey]) {\n      return;\n    }\n    for (var key in source[attrKey]) {\n      if (key in source[attrKey] && source[attrKey][key] === undefined) {\n        if (includes(booleanHtmlAttributes, key) && !warningShown) {\n          warn('VueMeta: Please note that since v2 the value undefined is not used to indicate boolean attributes anymore, see migration guide for details');\n          warningShown = true;\n        }\n        delete source[attrKey][key];\n      }\n    }\n  });\n  return deepmerge(target, source, {\n    arrayMerge: function arrayMerge(t, s) {\n      return _arrayMerge(options, t, s);\n    }\n  });\n}\nfunction getComponentMetaInfo(options, component) {\n  return getComponentOption(options || {}, component, defaultInfo);\n}\n/**\n * Returns the `opts.option` $option value of the given `opts.component`.\n * If methods are encountered, they will be bound to the component context.\n * If `opts.deep` is true, will recursively merge all child component\n * `opts.option` $option values into the returned result.\n *\n * @param  {Object} opts - options\n * @param  {Object} opts.component - Vue component to fetch option data from\n * @param  {Boolean} opts.deep - look for data in child components as well?\n * @param  {Function} opts.arrayMerge - how should arrays be merged?\n * @param  {String} opts.keyName - the name of the option to look for\n * @param  {Object} [result={}] - result so far\n * @return {Object} result - final aggregated result\n */\n\nfunction getComponentOption(options, component, result) {\n  result = result || {};\n  if (component._inactive) {\n    return result;\n  }\n  options = options || {};\n  var _options = options,\n    keyName = _options.keyName;\n  var $metaInfo = component.$metaInfo,\n    $options = component.$options,\n    $children = component.$children; // only collect option data if it exists\n\n  if ($options[keyName]) {\n    // if $metaInfo exists then [keyName] was defined as a function\n    // and set to the computed prop $metaInfo in the mixin\n    // using the computed prop should be a small performance increase\n    // because Vue caches those internally\n    var data = $metaInfo || $options[keyName]; // only merge data with result when its an object\n    // eg it could be a function when metaInfo() returns undefined\n    // dueo to the or statement above\n\n    if (isObject(data)) {\n      result = merge(result, data, options);\n    }\n  } // collect & aggregate child options if deep = true\n\n  if ($children.length) {\n    $children.forEach(function (childComponent) {\n      // check if the childComponent is in a branch\n      // return otherwise so we dont walk all component branches unnecessarily\n      if (!inMetaInfoBranch(childComponent)) {\n        return;\n      }\n      result = getComponentOption(options, childComponent, result);\n    });\n  }\n  return result;\n}\nvar callbacks = [];\nfunction isDOMComplete(d) {\n  return (d || document).readyState === 'complete';\n}\nfunction addCallback(query, callback) {\n  if (arguments.length === 1) {\n    callback = query;\n    query = '';\n  }\n  callbacks.push([query, callback]);\n}\nfunction addCallbacks(_ref, type, tags, autoAddListeners) {\n  var tagIDKeyName = _ref.tagIDKeyName;\n  var hasAsyncCallback = false;\n  tags.forEach(function (tag) {\n    if (!tag[tagIDKeyName] || !tag.callback) {\n      return;\n    }\n    hasAsyncCallback = true;\n    addCallback(\"\".concat(type, \"[data-\").concat(tagIDKeyName, \"=\\\"\").concat(tag[tagIDKeyName], \"\\\"]\"), tag.callback);\n  });\n  if (!autoAddListeners || !hasAsyncCallback) {\n    return hasAsyncCallback;\n  }\n  return addListeners();\n}\nfunction addListeners() {\n  if (isDOMComplete()) {\n    applyCallbacks();\n    return;\n  } // Instead of using a MutationObserver, we just apply\n\n  /* istanbul ignore next */\n\n  document.onreadystatechange = function () {\n    applyCallbacks();\n  };\n}\nfunction applyCallbacks(matchElement) {\n  callbacks.forEach(function (args) {\n    // do not use destructuring for args, it increases transpiled size\n    // due to var checks while we are guaranteed the structure of the cb\n    var query = args[0];\n    var callback = args[1];\n    var selector = \"\".concat(query, \"[onload=\\\"this.__vm_l=1\\\"]\");\n    var elements = [];\n    if (!matchElement) {\n      elements = toArray(querySelector(selector));\n    }\n    if (matchElement && matchElement.matches(selector)) {\n      elements = [matchElement];\n    }\n    elements.forEach(function (element) {\n      /* __vm_cb: whether the load callback has been called\n       * __vm_l: set by onload attribute, whether the element was loaded\n       * __vm_ev: whether the event listener was added or not\n       */\n      if (element.__vm_cb) {\n        return;\n      }\n      var onload = function onload() {\n        /* Mark that the callback for this element has already been called,\n         * this prevents the callback to run twice in some (rare) conditions\n         */\n        element.__vm_cb = true;\n        /* onload needs to be removed because we only need the\n         * attribute after ssr and if we dont remove it the node\n         * will fail isEqualNode on the client\n         */\n\n        removeAttribute(element, 'onload');\n        callback(element);\n      };\n      /* IE9 doesnt seem to load scripts synchronously,\n       * causing a script sometimes/often already to be loaded\n       * when we add the event listener below (thus adding an onload event\n       * listener has no use because it will never be triggered).\n       * Therefore we add the onload attribute during ssr, and\n       * check here if it was already loaded or not\n       */\n\n      if (element.__vm_l) {\n        onload();\n        return;\n      }\n      if (!element.__vm_ev) {\n        element.__vm_ev = true;\n        element.addEventListener('load', onload);\n      }\n    });\n  });\n}\n\n// instead of adding it to the html\n\nvar attributeMap = {};\n/**\n * Updates the document's html tag attributes\n *\n * @param  {Object} attrs - the new document html attributes\n * @param  {HTMLElement} tag - the HTMLElement tag to update with new attrs\n */\n\nfunction updateAttribute(appId, options, type, attrs, tag) {\n  var _ref = options || {},\n    attribute = _ref.attribute;\n  var vueMetaAttrString = tag.getAttribute(attribute);\n  if (vueMetaAttrString) {\n    attributeMap[type] = JSON.parse(decodeURI(vueMetaAttrString));\n    removeAttribute(tag, attribute);\n  }\n  var data = attributeMap[type] || {};\n  var toUpdate = []; // remove attributes from the map\n  // which have been removed for this appId\n\n  for (var attr in data) {\n    if (data[attr] !== undefined && appId in data[attr]) {\n      toUpdate.push(attr);\n      if (!attrs[attr]) {\n        delete data[attr][appId];\n      }\n    }\n  }\n  for (var _attr in attrs) {\n    var attrData = data[_attr];\n    if (!attrData || attrData[appId] !== attrs[_attr]) {\n      toUpdate.push(_attr);\n      if (attrs[_attr] !== undefined) {\n        data[_attr] = data[_attr] || {};\n        data[_attr][appId] = attrs[_attr];\n      }\n    }\n  }\n  for (var _i = 0, _toUpdate = toUpdate; _i < _toUpdate.length; _i++) {\n    var _attr2 = _toUpdate[_i];\n    var _attrData = data[_attr2];\n    var attrValues = [];\n    for (var _appId in _attrData) {\n      Array.prototype.push.apply(attrValues, [].concat(_attrData[_appId]));\n    }\n    if (attrValues.length) {\n      var attrValue = includes(booleanHtmlAttributes, _attr2) && attrValues.some(Boolean) ? '' : attrValues.filter(function (v) {\n        return v !== undefined;\n      }).join(' ');\n      tag.setAttribute(_attr2, attrValue);\n    } else {\n      removeAttribute(tag, _attr2);\n    }\n  }\n  attributeMap[type] = data;\n}\n\n/**\n * Updates the document title\n *\n * @param  {String} title - the new title of the document\n */\nfunction updateTitle(title) {\n  if (!title && title !== '') {\n    return;\n  }\n  document.title = title;\n}\n\n/**\n * Updates meta tags inside <head> and <body> on the client. Borrowed from `react-helmet`:\n * https://github.com/nfl/react-helmet/blob/004d448f8de5f823d10f838b02317521180f34da/src/Helmet.js#L195-L245\n *\n * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} type - the name of the tag\n * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n * @return {Object} - a representation of what tags changed\n */\n\nfunction updateTag(appId, options, type, tags, head, body) {\n  var _ref = options || {},\n    attribute = _ref.attribute,\n    tagIDKeyName = _ref.tagIDKeyName;\n  var dataAttributes = commonDataAttributes.slice();\n  dataAttributes.push(tagIDKeyName);\n  var newElements = [];\n  var queryOptions = {\n    appId: appId,\n    attribute: attribute,\n    type: type,\n    tagIDKeyName: tagIDKeyName\n  };\n  var currentElements = {\n    head: queryElements(head, queryOptions),\n    pbody: queryElements(body, queryOptions, {\n      pbody: true\n    }),\n    body: queryElements(body, queryOptions, {\n      body: true\n    })\n  };\n  if (tags.length > 1) {\n    // remove duplicates that could have been found by merging tags\n    // which include a mixin with metaInfo and that mixin is used\n    // by multiple components on the same page\n    var found = [];\n    tags = tags.filter(function (x) {\n      var k = JSON.stringify(x);\n      var res = !includes(found, k);\n      found.push(k);\n      return res;\n    });\n  }\n  tags.forEach(function (tag) {\n    if (tag.skip) {\n      return;\n    }\n    var newElement = document.createElement(type);\n    if (!tag.once) {\n      newElement.setAttribute(attribute, appId);\n    }\n    Object.keys(tag).forEach(function (attr) {\n      /* istanbul ignore next */\n      if (includes(tagProperties, attr)) {\n        return;\n      }\n      if (attr === 'innerHTML') {\n        newElement.innerHTML = tag.innerHTML;\n        return;\n      }\n      if (attr === 'json') {\n        newElement.innerHTML = JSON.stringify(tag.json);\n        return;\n      }\n      if (attr === 'cssText') {\n        if (newElement.styleSheet) {\n          /* istanbul ignore next */\n          newElement.styleSheet.cssText = tag.cssText;\n        } else {\n          newElement.appendChild(document.createTextNode(tag.cssText));\n        }\n        return;\n      }\n      if (attr === 'callback') {\n        newElement.onload = function () {\n          return tag[attr](newElement);\n        };\n        return;\n      }\n      var _attr = includes(dataAttributes, attr) ? \"data-\".concat(attr) : attr;\n      var isBooleanAttribute = includes(booleanHtmlAttributes, attr);\n      if (isBooleanAttribute && !tag[attr]) {\n        return;\n      }\n      var value = isBooleanAttribute ? '' : tag[attr];\n      newElement.setAttribute(_attr, value);\n    });\n    var oldElements = currentElements[getElementsKey(tag)]; // Remove a duplicate tag from domTagstoRemove, so it isn't cleared.\n\n    var indexToDelete;\n    var hasEqualElement = oldElements.some(function (existingTag, index) {\n      indexToDelete = index;\n      return newElement.isEqualNode(existingTag);\n    });\n    if (hasEqualElement && (indexToDelete || indexToDelete === 0)) {\n      oldElements.splice(indexToDelete, 1);\n    } else {\n      newElements.push(newElement);\n    }\n  });\n  var oldElements = [];\n  for (var _type in currentElements) {\n    Array.prototype.push.apply(oldElements, currentElements[_type]);\n  } // remove old elements\n\n  oldElements.forEach(function (element) {\n    element.parentNode.removeChild(element);\n  }); // insert new elements\n\n  newElements.forEach(function (element) {\n    if (element.hasAttribute('data-body')) {\n      body.appendChild(element);\n      return;\n    }\n    if (element.hasAttribute('data-pbody')) {\n      body.insertBefore(element, body.firstChild);\n      return;\n    }\n    head.appendChild(element);\n  });\n  return {\n    oldTags: oldElements,\n    newTags: newElements\n  };\n}\n\n/**\n * Performs client-side updates when new meta info is received\n *\n * @param  {Object} newInfo - the meta info to update to\n */\n\nfunction updateClientMetaInfo(appId, options, newInfo) {\n  options = options || {};\n  var _options = options,\n    ssrAttribute = _options.ssrAttribute,\n    ssrAppId = _options.ssrAppId; // only cache tags for current update\n\n  var tags = {};\n  var htmlTag = getTag(tags, 'html'); // if this is a server render, then dont update\n\n  if (appId === ssrAppId && htmlTag.hasAttribute(ssrAttribute)) {\n    // remove the server render attribute so we can update on (next) changes\n    removeAttribute(htmlTag, ssrAttribute); // add load callbacks if the\n\n    var addLoadListeners = false;\n    tagsSupportingOnload.forEach(function (type) {\n      if (newInfo[type] && addCallbacks(options, type, newInfo[type])) {\n        addLoadListeners = true;\n      }\n    });\n    if (addLoadListeners) {\n      addListeners();\n    }\n    return false;\n  } // initialize tracked changes\n\n  var tagsAdded = {};\n  var tagsRemoved = {};\n  for (var type in newInfo) {\n    // ignore these\n    if (includes(metaInfoOptionKeys, type)) {\n      continue;\n    }\n    if (type === 'title') {\n      // update the title\n      updateTitle(newInfo.title);\n      continue;\n    }\n    if (includes(metaInfoAttributeKeys, type)) {\n      var tagName = type.substr(0, 4);\n      updateAttribute(appId, options, type, newInfo[type], getTag(tags, tagName));\n      continue;\n    } // tags should always be an array, ignore if it isnt\n\n    if (!isArray(newInfo[type])) {\n      continue;\n    }\n    var _updateTag = updateTag(appId, options, type, newInfo[type], getTag(tags, 'head'), getTag(tags, 'body')),\n      oldTags = _updateTag.oldTags,\n      newTags = _updateTag.newTags;\n    if (newTags.length) {\n      tagsAdded[type] = newTags;\n      tagsRemoved[type] = oldTags;\n    }\n  }\n  return {\n    tagsAdded: tagsAdded,\n    tagsRemoved: tagsRemoved\n  };\n}\nvar appsMetaInfo;\nfunction addApp(rootVm, appId, options) {\n  return {\n    set: function set(metaInfo) {\n      return setMetaInfo(rootVm, appId, options, metaInfo);\n    },\n    remove: function remove() {\n      return removeMetaInfo(rootVm, appId, options);\n    }\n  };\n}\nfunction setMetaInfo(rootVm, appId, options, metaInfo) {\n  // if a vm exists _and_ its mounted then immediately update\n  if (rootVm && rootVm.$el) {\n    return updateClientMetaInfo(appId, options, metaInfo);\n  } // store for later, the info\n  // will be set on the first refresh\n\n  appsMetaInfo = appsMetaInfo || {};\n  appsMetaInfo[appId] = metaInfo;\n}\nfunction removeMetaInfo(rootVm, appId, options) {\n  if (rootVm && rootVm.$el) {\n    var tags = {};\n    var _iterator = _createForOfIteratorHelper(metaInfoAttributeKeys),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var type = _step.value;\n        var tagName = type.substr(0, 4);\n        updateAttribute(appId, options, type, {}, getTag(tags, tagName));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return removeElementsByAppId(options, appId);\n  }\n  if (appsMetaInfo[appId]) {\n    delete appsMetaInfo[appId];\n    clearAppsMetaInfo();\n  }\n}\nfunction getAppsMetaInfo() {\n  return appsMetaInfo;\n}\nfunction clearAppsMetaInfo(force) {\n  if (force || !Object.keys(appsMetaInfo).length) {\n    appsMetaInfo = undefined;\n  }\n}\n\n/**\n * Returns the correct meta info for the given component\n * (child components will overwrite parent meta info)\n *\n * @param  {Object} component - the Vue instance to get meta info from\n * @return {Object} - returned meta info\n */\n\nfunction getMetaInfo(options, info, escapeSequences, component) {\n  options = options || {};\n  escapeSequences = escapeSequences || [];\n  var _options = options,\n    tagIDKeyName = _options.tagIDKeyName; // Remove all \"template\" tags from meta\n  // backup the title chunk in case user wants access to it\n\n  if (info.title) {\n    info.titleChunk = info.title;\n  } // replace title with populated template\n\n  if (info.titleTemplate && info.titleTemplate !== '%s') {\n    applyTemplate({\n      component: component,\n      contentKeyName: 'title'\n    }, info, info.titleTemplate, info.titleChunk || '');\n  } // convert base tag to an array so it can be handled the same way\n  // as the other tags\n\n  if (info.base) {\n    info.base = Object.keys(info.base).length ? [info.base] : [];\n  }\n  if (info.meta) {\n    // remove meta items with duplicate vmid's\n    info.meta = info.meta.filter(function (metaItem, index, arr) {\n      var hasVmid = !!metaItem[tagIDKeyName];\n      if (!hasVmid) {\n        return true;\n      }\n      var isFirstItemForVmid = index === findIndex(arr, function (item) {\n        return item[tagIDKeyName] === metaItem[tagIDKeyName];\n      });\n      return isFirstItemForVmid;\n    }); // apply templates if needed\n\n    info.meta.forEach(function (metaObject) {\n      return applyTemplate(options, metaObject);\n    });\n  }\n  return escapeMetaInfo(options, info, escapeSequences);\n}\n\n/**\n * When called, will update the current meta info with new meta info.\n * Useful when updating meta info as the result of an asynchronous\n * action that resolves after the initial render takes place.\n *\n * Credit to [SÃ©bastien Chopin](https://github.com/Atinux) for the suggestion\n * to implement this method.\n *\n * @return {Object} - new meta info\n */\n\nfunction refresh(rootVm, options) {\n  options = options || {}; // make sure vue-meta was initiated\n\n  if (!rootVm[rootConfigKey]) {\n    showWarningNotSupported();\n    return {};\n  } // collect & aggregate all metaInfo $options\n\n  var rawInfo = getComponentMetaInfo(options, rootVm);\n  var metaInfo = getMetaInfo(options, rawInfo, clientSequences, rootVm);\n  var appId = rootVm[rootConfigKey].appId;\n  var tags = updateClientMetaInfo(appId, options, metaInfo); // emit \"event\" with new info\n\n  if (tags && isFunction(metaInfo.changed)) {\n    metaInfo.changed(metaInfo, tags.tagsAdded, tags.tagsRemoved);\n    tags = {\n      addedTags: tags.tagsAdded,\n      removedTags: tags.tagsRemoved\n    };\n  }\n  var appsMetaInfo = getAppsMetaInfo();\n  if (appsMetaInfo) {\n    for (var additionalAppId in appsMetaInfo) {\n      updateClientMetaInfo(additionalAppId, options, appsMetaInfo[additionalAppId]);\n      delete appsMetaInfo[additionalAppId];\n    }\n    clearAppsMetaInfo(true);\n  }\n  return {\n    vm: rootVm,\n    metaInfo: metaInfo,\n    // eslint-disable-line object-shorthand\n    tags: tags\n  };\n}\n\n/**\n * Generates tag attributes for use on the server.\n *\n * @param  {('bodyAttrs'|'htmlAttrs'|'headAttrs')} type - the type of attributes to generate\n * @param  {Object} data - the attributes to generate\n * @return {Object} - the attribute generator\n */\n\nfunction attributeGenerator(options, type, data, _ref) {\n  var addSsrAttribute = _ref.addSsrAttribute;\n  var _ref2 = options || {},\n    attribute = _ref2.attribute,\n    ssrAttribute = _ref2.ssrAttribute;\n  var attributeStr = '';\n  for (var attr in data) {\n    var attrData = data[attr];\n    var attrValues = [];\n    for (var appId in attrData) {\n      attrValues.push.apply(attrValues, _toConsumableArray([].concat(attrData[appId])));\n    }\n    if (attrValues.length) {\n      attributeStr += booleanHtmlAttributes.includes(attr) && attrValues.some(Boolean) ? \"\".concat(attr) : \"\".concat(attr, \"=\\\"\").concat(attrValues.join(' '), \"\\\"\");\n      attributeStr += ' ';\n    }\n  }\n  if (attributeStr) {\n    attributeStr += \"\".concat(attribute, \"=\\\"\").concat(encodeURI(JSON.stringify(data)), \"\\\"\");\n  }\n  if (type === 'htmlAttrs' && addSsrAttribute) {\n    return \"\".concat(ssrAttribute).concat(attributeStr ? ' ' : '').concat(attributeStr);\n  }\n  return attributeStr;\n}\n\n/**\n * Generates title output for the server\n *\n * @param  {'title'} type - the string \"title\"\n * @param  {String} data - the title text\n * @return {Object} - the title generator\n */\nfunction titleGenerator(options, type, data, generatorOptions) {\n  var _ref = generatorOptions || {},\n    ln = _ref.ln;\n  if (!data) {\n    return '';\n  }\n  return \"<\".concat(type, \">\").concat(data, \"</\").concat(type, \">\").concat(ln ? '\\n' : '');\n}\n\n/**\n * Generates meta, base, link, style, script, noscript tags for use on the server\n *\n * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} the name of the tag\n * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n * @return {Object} - the tag generator\n */\n\nfunction tagGenerator(options, type, tags, generatorOptions) {\n  var _ref = options || {},\n    ssrAppId = _ref.ssrAppId,\n    attribute = _ref.attribute,\n    tagIDKeyName = _ref.tagIDKeyName;\n  var _ref2 = generatorOptions || {},\n    appId = _ref2.appId,\n    _ref2$isSSR = _ref2.isSSR,\n    isSSR = _ref2$isSSR === void 0 ? true : _ref2$isSSR,\n    _ref2$body = _ref2.body,\n    body = _ref2$body === void 0 ? false : _ref2$body,\n    _ref2$pbody = _ref2.pbody,\n    pbody = _ref2$pbody === void 0 ? false : _ref2$pbody,\n    _ref2$ln = _ref2.ln,\n    ln = _ref2$ln === void 0 ? false : _ref2$ln;\n  var dataAttributes = [tagIDKeyName].concat(_toConsumableArray(commonDataAttributes));\n  if (!tags || !tags.length) {\n    return '';\n  } // build a string containing all tags of this type\n\n  return tags.reduce(function (tagsStr, tag) {\n    if (tag.skip) {\n      return tagsStr;\n    }\n    var tagKeys = Object.keys(tag);\n    if (tagKeys.length === 0) {\n      return tagsStr; // Bail on empty tag object\n    }\n\n    if (Boolean(tag.body) !== body || Boolean(tag.pbody) !== pbody) {\n      return tagsStr;\n    }\n    var attrs = tag.once ? '' : \" \".concat(attribute, \"=\\\"\").concat(appId || (isSSR === false ? '1' : ssrAppId), \"\\\"\"); // build a string containing all attributes of this tag\n\n    for (var attr in tag) {\n      // these attributes are treated as children on the tag\n      if (tagAttributeAsInnerContent.includes(attr) || tagProperties.includes(attr)) {\n        continue;\n      }\n      if (attr === 'callback') {\n        attrs += ' onload=\"this.__vm_l=1\"';\n        continue;\n      } // these form the attribute list for this tag\n\n      var prefix = '';\n      if (dataAttributes.includes(attr)) {\n        prefix = 'data-';\n      }\n      var isBooleanAttr = !prefix && booleanHtmlAttributes.includes(attr);\n      if (isBooleanAttr && !tag[attr]) {\n        continue;\n      }\n      attrs += \" \".concat(prefix).concat(attr) + (isBooleanAttr ? '' : \"=\\\"\".concat(tag[attr], \"\\\"\"));\n    }\n    var json = '';\n    if (tag.json) {\n      json = JSON.stringify(tag.json);\n    } // grab child content from one of these attributes, if possible\n\n    var content = tag.innerHTML || tag.cssText || json; // generate tag exactly without any other redundant attribute\n    // these tags have no end tag\n\n    var hasEndTag = !tagsWithoutEndTag.includes(type); // these tag types will have content inserted\n\n    var hasContent = hasEndTag && tagsWithInnerContent.includes(type); // the final string for this specific tag\n\n    return \"\".concat(tagsStr, \"<\").concat(type).concat(attrs).concat(!hasContent && hasEndTag ? '/' : '', \">\") + (hasContent ? \"\".concat(content, \"</\").concat(type, \">\") : '') + (ln ? '\\n' : '');\n  }, '');\n}\n\n/**\n * Converts a meta info property to one that can be stringified on the server\n *\n * @param  {String} type - the type of data to convert\n * @param  {(String|Object|Array<Object>)} data - the data value\n * @return {Object} - the new injector\n */\n\nfunction generateServerInjector(options, metaInfo, globalInjectOptions) {\n  var serverInjector = {\n    data: metaInfo,\n    extraData: undefined,\n    addInfo: function addInfo(appId, metaInfo) {\n      this.extraData = this.extraData || {};\n      this.extraData[appId] = metaInfo;\n    },\n    callInjectors: function callInjectors(opts) {\n      var m = this.injectors; // only call title for the head\n\n      return (opts.body || opts.pbody ? '' : m.title.text(opts)) + m.meta.text(opts) + m.base.text(opts) + m.link.text(opts) + m.style.text(opts) + m.script.text(opts) + m.noscript.text(opts);\n    },\n    injectors: {\n      head: function head(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln\n        }));\n      },\n      bodyPrepend: function bodyPrepend(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln,\n          pbody: true\n        }));\n      },\n      bodyAppend: function bodyAppend(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln,\n          body: true\n        }));\n      }\n    }\n  };\n  var _loop = function _loop(type) {\n    if (metaInfoOptionKeys.includes(type)) {\n      return \"continue\";\n    }\n    serverInjector.injectors[type] = {\n      text: function text(injectOptions) {\n        var addSsrAttribute = injectOptions === true;\n        injectOptions = _objectSpread2(_objectSpread2({\n          addSsrAttribute: addSsrAttribute\n        }, globalInjectOptions), injectOptions);\n        if (type === 'title') {\n          return titleGenerator(options, type, serverInjector.data[type], injectOptions);\n        }\n        if (metaInfoAttributeKeys.includes(type)) {\n          var attributeData = {};\n          var data = serverInjector.data[type];\n          if (data) {\n            var appId = injectOptions.isSSR === false ? '1' : options.ssrAppId;\n            for (var attr in data) {\n              attributeData[attr] = _defineProperty({}, appId, data[attr]);\n            }\n          }\n          if (serverInjector.extraData) {\n            for (var _appId in serverInjector.extraData) {\n              var _data = serverInjector.extraData[_appId][type];\n              if (_data) {\n                for (var _attr in _data) {\n                  attributeData[_attr] = _objectSpread2(_objectSpread2({}, attributeData[_attr]), {}, _defineProperty({}, _appId, _data[_attr]));\n                }\n              }\n            }\n          }\n          return attributeGenerator(options, type, attributeData, injectOptions);\n        }\n        var str = tagGenerator(options, type, serverInjector.data[type], injectOptions);\n        if (serverInjector.extraData) {\n          for (var _appId2 in serverInjector.extraData) {\n            var _data2 = serverInjector.extraData[_appId2][type];\n            var extraStr = tagGenerator(options, type, _data2, _objectSpread2({\n              appId: _appId2\n            }, injectOptions));\n            str = \"\".concat(str).concat(extraStr);\n          }\n        }\n        return str;\n      }\n    };\n  };\n  for (var type in defaultInfo) {\n    var _ret = _loop(type);\n    if (_ret === \"continue\") continue;\n  }\n  return serverInjector;\n}\n\n/**\n * Converts the state of the meta info object such that each item\n * can be compiled to a tag string on the server\n *\n * @vm {Object} - Vue instance - ideally the root component\n * @return {Object} - server meta info with `toString` methods\n */\n\nfunction inject(rootVm, options, injectOptions) {\n  // make sure vue-meta was initiated\n  if (!rootVm[rootConfigKey]) {\n    showWarningNotSupported();\n    return {};\n  } // collect & aggregate all metaInfo $options\n\n  var rawInfo = getComponentMetaInfo(options, rootVm);\n  var metaInfo = getMetaInfo(options, rawInfo, serverSequences, rootVm); // generate server injector\n\n  var serverInjector = generateServerInjector(options, metaInfo, injectOptions); // add meta info from additional apps\n\n  var appsMetaInfo = getAppsMetaInfo();\n  if (appsMetaInfo) {\n    for (var additionalAppId in appsMetaInfo) {\n      serverInjector.addInfo(additionalAppId, appsMetaInfo[additionalAppId]);\n      delete appsMetaInfo[additionalAppId];\n    }\n    clearAppsMetaInfo(true);\n  }\n  return serverInjector.injectors;\n}\nfunction $meta(options) {\n  options = options || {};\n  /**\n   * Returns an injector for server-side rendering.\n   * @this {Object} - the Vue instance (a root component)\n   * @return {Object} - injector\n   */\n\n  var $root = this.$root;\n  return {\n    getOptions: function getOptions$1() {\n      return getOptions(options);\n    },\n    setOptions: function setOptions(newOptions) {\n      var refreshNavKey = 'refreshOnceOnNavigation';\n      if (newOptions && newOptions[refreshNavKey]) {\n        options.refreshOnceOnNavigation = !!newOptions[refreshNavKey];\n        addNavGuards($root);\n      }\n      var debounceWaitKey = 'debounceWait';\n      if (newOptions && debounceWaitKey in newOptions) {\n        var debounceWait = parseInt(newOptions[debounceWaitKey]);\n        if (!isNaN(debounceWait)) {\n          options.debounceWait = debounceWait;\n        }\n      }\n      var waitOnDestroyedKey = 'waitOnDestroyed';\n      if (newOptions && waitOnDestroyedKey in newOptions) {\n        options.waitOnDestroyed = !!newOptions[waitOnDestroyedKey];\n      }\n    },\n    refresh: function refresh$1() {\n      return refresh($root, options);\n    },\n    inject: function inject$1(injectOptions) {\n      return inject($root, options, injectOptions);\n    },\n    pause: function pause$1() {\n      return pause($root);\n    },\n    resume: function resume$1() {\n      return resume($root);\n    },\n    addApp: function addApp$1(appId) {\n      return addApp($root, appId, options);\n    }\n  };\n}\nfunction generate(rawInfo, options) {\n  options = setOptions(options);\n  var metaInfo = getMetaInfo(options, rawInfo, serverSequences);\n  var serverInjector = generateServerInjector(options, metaInfo);\n  return serverInjector.injectors;\n}\n\n/**\n * Plugin install function.\n * @param {Function} Vue - the Vue constructor.\n */\n\nfunction install(Vue, options) {\n  if (Vue.__vuemeta_installed) {\n    return;\n  }\n  Vue.__vuemeta_installed = true;\n  options = setOptions(options);\n  Vue.prototype.$meta = function () {\n    return $meta.call(this, options);\n  };\n  Vue.mixin(createMixin(Vue, options));\n}\nvar index = {\n  version: version,\n  install: install,\n  generate: function generate$1(metaInfo, options) {\n    return generate(metaInfo, options);\n  },\n  hasMetaInfo: hasMetaInfo\n};\nexport default index;","map":{"version":3,"names":["deepmerge","version","_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperty","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","from","o","minLen","n","toString","call","slice","name","test","len","arr2","TypeError","_createForOfIteratorHelper","allowArrayLike","it","F","s","done","e","f","normalCompletion","didErr","err","step","next","return","arg","isUndefined","isObject","isPureObject","isFunction","isString","hasGlobalWindowFn","window","hasGlobalWindow","_global","global","console","warn","str","showWarningNotSupported","defaultInfo","title","undefined","titleChunk","titleTemplate","htmlAttrs","bodyAttrs","headAttrs","base","link","meta","style","script","noscript","__dangerouslyDisableSanitizers","__dangerouslyDisableSanitizersByTagID","rootConfigKey","keyName","attribute","ssrAttribute","tagIDKeyName","metaTemplateKeyName","contentKeyName","ssrAppId","debounceWait","waitOnDestroyed","defaultOptions","defaultInfoKeys","disableOptionKeys","metaInfoOptionKeys","concat","metaInfoAttributeKeys","tagsSupportingOnload","tagsWithoutEndTag","tagsWithInnerContent","tagAttributeAsInnerContent","tagProperties","commonDataAttributes","booleanHtmlAttributes","batchId","triggerUpdate","_ref","rootVm","hookName","initialized","initializing","pausing","batchUpdate","$meta","refresh","callback","timeout","clearTimeout","setTimeout","find","array","predicate","thisArg","idx","findIndex","toArray","includes","querySelector","el","document","querySelectorAll","getTag","tags","tag","getElementsByTagName","getElementsKey","body","pbody","queryElements","parentNode","_ref2","attributes","appId","type","queries","map","query","val","attributeValue","join","removeElementsByAppId","_ref3","remove","removeAttribute","attributeName","hasMetaInfo","vm","inMetaInfoBranch","pause","resume","addNavGuards","router","$router","navGuards","beforeEach","to","afterEach","$nextTick","_resume","metaInfo","afterNavigation","createMixin","Vue","options","updateOnLifecycleHook","wasServerRendered","beforeCreate","_this2","rootKey","$root","$options","devtoolsEnabled","config","devtools","get","deprecationWarningShown","$once","$el","nodeType","hasAttribute","htmlTag","child","$children","c","$vnode","fnOptions","parent","$parent","computed","$metaInfo","$isServer","$on","$watch","initializedSsr","_$root$$meta$refresh","refreshOnceOnNavigation","_this","_hasMetaInfo","offsetParent","interval","setInterval","clearInterval","lifecycleHook","setOptions","getOptions","optionsCopy","ensureIsArray","serverSequences","clientSequences","escape","info","escapeOptions","escapeKeys","_escapeOptions$doEsca","doEscape","v","escaped","disableKey","tagId","escapedKey","escapeMetaInfo","escapeSequences","reduce","seq","replace","index","applyTemplate","headObject","template","chunk","component","_arrayMerge","destination","targetItem","targetIndex","sourceIndex","item","sourceItem","innerHTML","splice","targetTemplate","sourceTemplate","warningShown","merge","attrKey","arrayMerge","t","getComponentMetaInfo","getComponentOption","result","_inactive","_options","data","childComponent","callbacks","isDOMComplete","d","readyState","addCallback","addCallbacks","autoAddListeners","hasAsyncCallback","addListeners","applyCallbacks","onreadystatechange","matchElement","args","selector","elements","matches","element","__vm_cb","onload","__vm_l","__vm_ev","addEventListener","attributeMap","updateAttribute","attrs","vueMetaAttrString","getAttribute","JSON","parse","decodeURI","toUpdate","attr","_attr","attrData","_i","_toUpdate","_attr2","_attrData","attrValues","_appId","attrValue","some","Boolean","setAttribute","updateTitle","updateTag","head","dataAttributes","newElements","queryOptions","currentElements","found","x","k","stringify","res","skip","newElement","createElement","once","json","styleSheet","cssText","appendChild","createTextNode","isBooleanAttribute","oldElements","indexToDelete","hasEqualElement","existingTag","isEqualNode","_type","removeChild","insertBefore","firstChild","oldTags","newTags","updateClientMetaInfo","newInfo","addLoadListeners","tagsAdded","tagsRemoved","tagName","substr","_updateTag","appsMetaInfo","addApp","set","setMetaInfo","removeMetaInfo","_iterator","_step","clearAppsMetaInfo","getAppsMetaInfo","force","getMetaInfo","metaItem","hasVmid","isFirstItemForVmid","metaObject","rawInfo","changed","addedTags","removedTags","additionalAppId","attributeGenerator","addSsrAttribute","attributeStr","encodeURI","titleGenerator","generatorOptions","ln","tagGenerator","_ref2$isSSR","isSSR","_ref2$body","_ref2$pbody","_ref2$ln","tagsStr","tagKeys","prefix","isBooleanAttr","content","hasEndTag","hasContent","generateServerInjector","globalInjectOptions","serverInjector","extraData","addInfo","callInjectors","opts","m","injectors","text","bodyPrepend","bodyAppend","_loop","injectOptions","attributeData","_data","_appId2","_data2","extraStr","_ret","inject","getOptions$1","newOptions","refreshNavKey","debounceWaitKey","parseInt","isNaN","waitOnDestroyedKey","refresh$1","inject$1","pause$1","resume$1","addApp$1","generate","install","__vuemeta_installed","mixin","generate$1"],"sources":["/home/fran/Escritorio/DigicardVue/proyectos/vuetify-1/node_modules/vue-meta/dist/vue-meta.esm.js"],"sourcesContent":["/**\n * vue-meta v2.4.0\n * (c) 2020\n * - Declan de Wet\n * - SÃ©bastien Chopin (@Atinux)\n * - Pim (@pimlie)\n * - All the amazing contributors\n * @license MIT\n */\n\nimport deepmerge from 'deepmerge';\n\nvar version = \"2.4.0\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\n/**\n * checks if passed argument is an array\n * @param  {any}  arg - the object to check\n * @return {Boolean} - true if `arg` is an array\n */\nfunction isArray(arg) {\n  return Array.isArray(arg);\n}\nfunction isUndefined(arg) {\n  return typeof arg === 'undefined';\n}\nfunction isObject(arg) {\n  return _typeof(arg) === 'object';\n}\nfunction isPureObject(arg) {\n  return _typeof(arg) === 'object' && arg !== null;\n}\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\n\nfunction hasGlobalWindowFn() {\n  try {\n    return !isUndefined(window);\n  } catch (e) {\n    return false;\n  }\n}\nvar hasGlobalWindow = hasGlobalWindowFn();\n\nvar _global = hasGlobalWindow ? window : global;\n\nvar console = _global.console || {};\nfunction warn(str) {\n  /* istanbul ignore next */\n  if (!console || !console.warn) {\n    return;\n  }\n\n  console.warn(str);\n}\nvar showWarningNotSupported = function showWarningNotSupported() {\n  return warn('This vue app/component has no vue-meta configuration');\n};\n\n/**\n * These are constant variables used throughout the application.\n */\n// set some sane defaults\nvar defaultInfo = {\n  title: undefined,\n  titleChunk: '',\n  titleTemplate: '%s',\n  htmlAttrs: {},\n  bodyAttrs: {},\n  headAttrs: {},\n  base: [],\n  link: [],\n  meta: [],\n  style: [],\n  script: [],\n  noscript: [],\n  __dangerouslyDisableSanitizers: [],\n  __dangerouslyDisableSanitizersByTagID: {}\n};\nvar rootConfigKey = '_vueMeta'; // This is the name of the component option that contains all the information that\n// gets converted to the various meta tags & attributes for the page.\n\nvar keyName = 'metaInfo'; // This is the attribute vue-meta arguments on elements to know which it should\n// manage and which it should ignore.\n\nvar attribute = 'data-vue-meta'; // This is the attribute that goes on the `html` tag to inform `vue-meta`\n// that the server has already generated the meta tags for the initial render.\n\nvar ssrAttribute = 'data-vue-meta-server-rendered'; // This is the property that tells vue-meta to overwrite (instead of append)\n// an item in a tag list. For example, if you have two `meta` tag list items\n// that both have `vmid` of \"description\", then vue-meta will overwrite the\n// shallowest one with the deepest one.\n\nvar tagIDKeyName = 'vmid'; // This is the key name for possible meta templates\n\nvar metaTemplateKeyName = 'template'; // This is the key name for the content-holding property\n\nvar contentKeyName = 'content'; // The id used for the ssr app\n\nvar ssrAppId = 'ssr'; // How long meta update\n\nvar debounceWait = 10; // How long meta update\n\nvar waitOnDestroyed = true;\nvar defaultOptions = {\n  keyName: keyName,\n  attribute: attribute,\n  ssrAttribute: ssrAttribute,\n  tagIDKeyName: tagIDKeyName,\n  contentKeyName: contentKeyName,\n  metaTemplateKeyName: metaTemplateKeyName,\n  waitOnDestroyed: waitOnDestroyed,\n  debounceWait: debounceWait,\n  ssrAppId: ssrAppId\n}; // might be a bit ugly, but minimizes the browser bundles a bit\n\nvar defaultInfoKeys = Object.keys(defaultInfo); // The metaInfo property keys which are used to disable escaping\n\nvar disableOptionKeys = [defaultInfoKeys[12], defaultInfoKeys[13]]; // List of metaInfo property keys which are configuration options (and dont generate html)\n\nvar metaInfoOptionKeys = [defaultInfoKeys[1], defaultInfoKeys[2], 'changed'].concat(disableOptionKeys); // List of metaInfo property keys which only generates attributes and no tags\n\nvar metaInfoAttributeKeys = [defaultInfoKeys[3], defaultInfoKeys[4], defaultInfoKeys[5]]; // HTML elements which support the onload event\n\nvar tagsSupportingOnload = ['link', 'style', 'script']; // HTML elements which dont have a head tag (shortened to our needs)\n// see: https://www.w3.org/TR/html52/document-metadata.html\n\nvar tagsWithoutEndTag = ['base', 'meta', 'link']; // HTML elements which can have inner content (shortened to our needs)\n\nvar tagsWithInnerContent = ['noscript', 'script', 'style']; // Attributes which are inserted as childNodes instead of HTMLAttribute\n\nvar tagAttributeAsInnerContent = ['innerHTML', 'cssText', 'json'];\nvar tagProperties = ['once', 'skip', 'template']; // Attributes which should be added with data- prefix\n\nvar commonDataAttributes = ['body', 'pbody']; // from: https://github.com/kangax/html-minifier/blob/gh-pages/src/htmlminifier.js#L202\n\nvar booleanHtmlAttributes = ['allowfullscreen', 'amp', 'amp-boilerplate', 'async', 'autofocus', 'autoplay', 'checked', 'compact', 'controls', 'declare', 'default', 'defaultchecked', 'defaultmuted', 'defaultselected', 'defer', 'disabled', 'enabled', 'formnovalidate', 'hidden', 'indeterminate', 'inert', 'ismap', 'itemscope', 'loop', 'multiple', 'muted', 'nohref', 'noresize', 'noshade', 'novalidate', 'nowrap', 'open', 'pauseonexit', 'readonly', 'required', 'reversed', 'scoped', 'seamless', 'selected', 'sortable', 'truespeed', 'typemustmatch', 'visible'];\n\nvar batchId = null;\nfunction triggerUpdate(_ref, rootVm, hookName) {\n  var debounceWait = _ref.debounceWait;\n\n  // if an update was triggered during initialization or when an update was triggered by the\n  // metaInfo watcher, set initialized to null\n  // then we keep falsy value but know we need to run a triggerUpdate after initialization\n  if (!rootVm[rootConfigKey].initialized && (rootVm[rootConfigKey].initializing || hookName === 'watcher')) {\n    rootVm[rootConfigKey].initialized = null;\n  }\n\n  if (rootVm[rootConfigKey].initialized && !rootVm[rootConfigKey].pausing) {\n    // batch potential DOM updates to prevent extraneous re-rendering\n    // eslint-disable-next-line no-void\n    batchUpdate(function () {\n      return void rootVm.$meta().refresh();\n    }, debounceWait);\n  }\n}\n/**\n * Performs a batched update.\n *\n * @param  {(null|Number)} id - the ID of this update\n * @param  {Function} callback - the update to perform\n * @return {Number} id - a new ID\n */\n\nfunction batchUpdate(callback, timeout) {\n  timeout = timeout === undefined ? 10 : timeout;\n\n  if (!timeout) {\n    callback();\n    return;\n  }\n\n  clearTimeout(batchId);\n  batchId = setTimeout(function () {\n    callback();\n  }, timeout);\n  return batchId;\n}\n\n/*\n * To reduce build size, this file provides simple polyfills without\n * overly excessive type checking and without modifying\n * the global Array.prototype\n * The polyfills are automatically removed in the commonjs build\n * Also, only files in client/ & shared/ should use these functions\n * files in server/ still use normal js function\n */\nfunction find(array, predicate, thisArg) {\n  if ( !Array.prototype.find) {\n    // idx needs to be a Number, for..in returns string\n    for (var idx = 0; idx < array.length; idx++) {\n      if (predicate.call(thisArg, array[idx], idx, array)) {\n        return array[idx];\n      }\n    }\n\n    return;\n  }\n\n  return array.find(predicate, thisArg);\n}\nfunction findIndex(array, predicate, thisArg) {\n  if ( !Array.prototype.findIndex) {\n    // idx needs to be a Number, for..in returns string\n    for (var idx = 0; idx < array.length; idx++) {\n      if (predicate.call(thisArg, array[idx], idx, array)) {\n        return idx;\n      }\n    }\n\n    return -1;\n  }\n\n  return array.findIndex(predicate, thisArg);\n}\nfunction toArray(arg) {\n  if ( !Array.from) {\n    return Array.prototype.slice.call(arg);\n  }\n\n  return Array.from(arg);\n}\nfunction includes(array, value) {\n  if ( !Array.prototype.includes) {\n    for (var idx in array) {\n      if (array[idx] === value) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return array.includes(value);\n}\n\nvar querySelector = function querySelector(arg, el) {\n  return (el || document).querySelectorAll(arg);\n};\nfunction getTag(tags, tag) {\n  if (!tags[tag]) {\n    tags[tag] = document.getElementsByTagName(tag)[0];\n  }\n\n  return tags[tag];\n}\nfunction getElementsKey(_ref) {\n  var body = _ref.body,\n      pbody = _ref.pbody;\n  return body ? 'body' : pbody ? 'pbody' : 'head';\n}\nfunction queryElements(parentNode, _ref2, attributes) {\n  var appId = _ref2.appId,\n      attribute = _ref2.attribute,\n      type = _ref2.type,\n      tagIDKeyName = _ref2.tagIDKeyName;\n  attributes = attributes || {};\n  var queries = [\"\".concat(type, \"[\").concat(attribute, \"=\\\"\").concat(appId, \"\\\"]\"), \"\".concat(type, \"[data-\").concat(tagIDKeyName, \"]\")].map(function (query) {\n    for (var key in attributes) {\n      var val = attributes[key];\n      var attributeValue = val && val !== true ? \"=\\\"\".concat(val, \"\\\"\") : '';\n      query += \"[data-\".concat(key).concat(attributeValue, \"]\");\n    }\n\n    return query;\n  });\n  return toArray(querySelector(queries.join(', '), parentNode));\n}\nfunction removeElementsByAppId(_ref3, appId) {\n  var attribute = _ref3.attribute;\n  toArray(querySelector(\"[\".concat(attribute, \"=\\\"\").concat(appId, \"\\\"]\"))).map(function (el) {\n    return el.remove();\n  });\n}\nfunction removeAttribute(el, attributeName) {\n  el.removeAttribute(attributeName);\n}\n\nfunction hasMetaInfo(vm) {\n  vm = vm || this;\n  return vm && (vm[rootConfigKey] === true || isObject(vm[rootConfigKey]));\n} // a component is in a metaInfo branch when itself has meta info or one of its (grand-)children has\n\nfunction inMetaInfoBranch(vm) {\n  vm = vm || this;\n  return vm && !isUndefined(vm[rootConfigKey]);\n}\n\nfunction pause(rootVm, refresh) {\n  rootVm[rootConfigKey].pausing = true;\n  return function () {\n    return resume(rootVm, refresh);\n  };\n}\nfunction resume(rootVm, refresh) {\n  rootVm[rootConfigKey].pausing = false;\n\n  if (refresh || refresh === undefined) {\n    return rootVm.$meta().refresh();\n  }\n}\n\nfunction addNavGuards(rootVm) {\n  var router = rootVm.$router; // return when nav guards already added or no router exists\n\n  if (rootVm[rootConfigKey].navGuards || !router) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  rootVm[rootConfigKey].navGuards = true;\n  router.beforeEach(function (to, from, next) {\n    pause(rootVm);\n    next();\n  });\n  router.afterEach(function () {\n    rootVm.$nextTick(function () {\n      var _resume = resume(rootVm),\n          metaInfo = _resume.metaInfo;\n\n      if (metaInfo && isFunction(metaInfo.afterNavigation)) {\n        metaInfo.afterNavigation(metaInfo);\n      }\n    });\n  });\n}\n\nvar appId = 1;\nfunction createMixin(Vue, options) {\n  // for which Vue lifecycle hooks should the metaInfo be refreshed\n  var updateOnLifecycleHook = ['activated', 'deactivated', 'beforeMount'];\n  var wasServerRendered = false; // watch for client side component updates\n\n  return {\n    beforeCreate: function beforeCreate() {\n      var _this2 = this;\n\n      var rootKey = '$root';\n      var $root = this[rootKey];\n      var $options = this.$options;\n      var devtoolsEnabled = Vue.config.devtools;\n      Object.defineProperty(this, '_hasMetaInfo', {\n        configurable: true,\n        get: function get() {\n          // Show deprecation warning once when devtools enabled\n          if (devtoolsEnabled && !$root[rootConfigKey].deprecationWarningShown) {\n            warn('VueMeta DeprecationWarning: _hasMetaInfo has been deprecated and will be removed in a future version. Please use hasMetaInfo(vm) instead');\n            $root[rootConfigKey].deprecationWarningShown = true;\n          }\n\n          return hasMetaInfo(this);\n        }\n      });\n\n      if (this === $root) {\n        $root.$once('hook:beforeMount', function () {\n          wasServerRendered = this.$el && this.$el.nodeType === 1 && this.$el.hasAttribute('data-server-rendered'); // In most cases when you have a SSR app it will be the first app thats gonna be\n          // initiated, if we cant detect the data-server-rendered attribute from Vue but we\n          // do see our own ssrAttribute then _assume_ the Vue app with appId 1 is the ssr app\n          // attempted fix for #404 & #562, but we rly need to refactor how we pass appIds from\n          // ssr to the client\n\n          if (!wasServerRendered && $root[rootConfigKey] && $root[rootConfigKey].appId === 1) {\n            var htmlTag = getTag({}, 'html');\n            wasServerRendered = htmlTag && htmlTag.hasAttribute(options.ssrAttribute);\n          }\n        });\n      } // Add a marker to know if it uses metaInfo\n      // _vnode is used to know that it's attached to a real component\n      // useful if we use some mixin to add some meta tags (like nuxt-i18n)\n\n\n      if (isUndefined($options[options.keyName]) || $options[options.keyName] === null) {\n        return;\n      }\n\n      if (!$root[rootConfigKey]) {\n        $root[rootConfigKey] = {\n          appId: appId\n        };\n        appId++;\n\n        if (devtoolsEnabled && $root.$options[options.keyName]) {\n          // use nextTick so the children should be added to $root\n          this.$nextTick(function () {\n            // find the first child that lists fnOptions\n            var child = find($root.$children, function (c) {\n              return c.$vnode && c.$vnode.fnOptions;\n            });\n\n            if (child && child.$vnode.fnOptions[options.keyName]) {\n              warn(\"VueMeta has detected a possible global mixin which adds a \".concat(options.keyName, \" property to all Vue components on the page. This could cause severe performance issues. If possible, use $meta().addApp to add meta information instead\"));\n            }\n          });\n        }\n      } // to speed up updates we keep track of branches which have a component with vue-meta info defined\n      // if _vueMeta = true it has info, if _vueMeta = false a child has info\n\n\n      if (!this[rootConfigKey]) {\n        this[rootConfigKey] = true;\n        var parent = this.$parent;\n\n        while (parent && parent !== $root) {\n          if (isUndefined(parent[rootConfigKey])) {\n            parent[rootConfigKey] = false;\n          }\n\n          parent = parent.$parent;\n        }\n      } // coerce function-style metaInfo to a computed prop so we can observe\n      // it on creation\n\n\n      if (isFunction($options[options.keyName])) {\n        $options.computed = $options.computed || {};\n        $options.computed.$metaInfo = $options[options.keyName];\n\n        if (!this.$isServer) {\n          // if computed $metaInfo exists, watch it for updates & trigger a refresh\n          // when it changes (i.e. automatically handle async actions that affect metaInfo)\n          // credit for this suggestion goes to [SÃ©bastien Chopin](https://github.com/Atinux)\n          this.$on('hook:created', function () {\n            this.$watch('$metaInfo', function () {\n              triggerUpdate(options, this[rootKey], 'watcher');\n            });\n          });\n        }\n      } // force an initial refresh on page load and prevent other lifecycleHooks\n      // to triggerUpdate until this initial refresh is finished\n      // this is to make sure that when a page is opened in an inactive tab which\n      // has throttled rAF/timers we still immediately set the page title\n\n\n      if (isUndefined($root[rootConfigKey].initialized)) {\n        $root[rootConfigKey].initialized = this.$isServer;\n\n        if (!$root[rootConfigKey].initialized) {\n          if (!$root[rootConfigKey].initializedSsr) {\n            $root[rootConfigKey].initializedSsr = true;\n            this.$on('hook:beforeMount', function () {\n              var $root = this[rootKey]; // if this Vue-app was server rendered, set the appId to 'ssr'\n              // only one SSR app per page is supported\n\n              if (wasServerRendered) {\n                $root[rootConfigKey].appId = options.ssrAppId;\n              }\n            });\n          } // we use the mounted hook here as on page load\n\n\n          this.$on('hook:mounted', function () {\n            var $root = this[rootKey];\n\n            if ($root[rootConfigKey].initialized) {\n              return;\n            } // used in triggerUpdate to check if a change was triggered\n            // during initialization\n\n\n            $root[rootConfigKey].initializing = true; // refresh meta in nextTick so all child components have loaded\n\n            this.$nextTick(function () {\n              var _$root$$meta$refresh = $root.$meta().refresh(),\n                  tags = _$root$$meta$refresh.tags,\n                  metaInfo = _$root$$meta$refresh.metaInfo; // After ssr hydration (identifier by tags === false) check\n              // if initialized was set to null in triggerUpdate. That'd mean\n              // that during initilazation changes where triggered which need\n              // to be applied OR a metaInfo watcher was triggered before the\n              // current hook was called\n              // (during initialization all changes are blocked)\n\n\n              if (tags === false && $root[rootConfigKey].initialized === null) {\n                this.$nextTick(function () {\n                  return triggerUpdate(options, $root, 'init');\n                });\n              }\n\n              $root[rootConfigKey].initialized = true;\n              delete $root[rootConfigKey].initializing; // add the navigation guards if they havent been added yet\n              // they are needed for the afterNavigation callback\n\n              if (!options.refreshOnceOnNavigation && metaInfo.afterNavigation) {\n                addNavGuards($root);\n              }\n            });\n          }); // add the navigation guards if requested\n\n          if (options.refreshOnceOnNavigation) {\n            addNavGuards($root);\n          }\n        }\n      }\n\n      this.$on('hook:destroyed', function () {\n        var _this = this;\n\n        // do not trigger refresh:\n        // - when user configured to not wait for transitions on destroyed\n        // - when the component doesnt have a parent\n        // - doesnt have metaInfo defined\n        if (!this.$parent || !hasMetaInfo(this)) {\n          return;\n        }\n\n        delete this._hasMetaInfo;\n        this.$nextTick(function () {\n          if (!options.waitOnDestroyed || !_this.$el || !_this.$el.offsetParent) {\n            triggerUpdate(options, _this.$root, 'destroyed');\n            return;\n          } // Wait that element is hidden before refreshing meta tags (to support animations)\n\n\n          var interval = setInterval(function () {\n            if (_this.$el && _this.$el.offsetParent !== null) {\n              /* istanbul ignore next line */\n              return;\n            }\n\n            clearInterval(interval);\n            triggerUpdate(options, _this.$root, 'destroyed');\n          }, 50);\n        });\n      }); // do not trigger refresh on the server side\n\n      if (this.$isServer) {\n        /* istanbul ignore next */\n        return;\n      } // no need to add this hooks on server side\n\n\n      updateOnLifecycleHook.forEach(function (lifecycleHook) {\n        _this2.$on(\"hook:\".concat(lifecycleHook), function () {\n          triggerUpdate(options, this[rootKey], lifecycleHook);\n        });\n      });\n    }\n  };\n}\n\nfunction setOptions(options) {\n  // combine options\n  options = isObject(options) ? options : {}; // The options are set like this so they can\n  // be minified by terser while keeping the\n  // user api intact\n  // terser --mangle-properties keep_quoted=strict\n\n  /* eslint-disable dot-notation */\n\n  return {\n    keyName: options['keyName'] || defaultOptions.keyName,\n    attribute: options['attribute'] || defaultOptions.attribute,\n    ssrAttribute: options['ssrAttribute'] || defaultOptions.ssrAttribute,\n    tagIDKeyName: options['tagIDKeyName'] || defaultOptions.tagIDKeyName,\n    contentKeyName: options['contentKeyName'] || defaultOptions.contentKeyName,\n    metaTemplateKeyName: options['metaTemplateKeyName'] || defaultOptions.metaTemplateKeyName,\n    debounceWait: isUndefined(options['debounceWait']) ? defaultOptions.debounceWait : options['debounceWait'],\n    waitOnDestroyed: isUndefined(options['waitOnDestroyed']) ? defaultOptions.waitOnDestroyed : options['waitOnDestroyed'],\n    ssrAppId: options['ssrAppId'] || defaultOptions.ssrAppId,\n    refreshOnceOnNavigation: !!options['refreshOnceOnNavigation']\n  };\n  /* eslint-enable dot-notation */\n}\nfunction getOptions(options) {\n  var optionsCopy = {};\n\n  for (var key in options) {\n    optionsCopy[key] = options[key];\n  }\n\n  return optionsCopy;\n}\n\nfunction ensureIsArray(arg, key) {\n  if (!key || !isObject(arg)) {\n    return isArray(arg) ? arg : [];\n  }\n\n  if (!isArray(arg[key])) {\n    arg[key] = [];\n  }\n\n  return arg;\n}\n\nvar serverSequences = [[/&/g, '&amp;'], [/</g, '&lt;'], [/>/g, '&gt;'], [/\"/g, '&quot;'], [/'/g, '&#x27;']];\nvar clientSequences = [[/&/g, \"&\"], [/</g, \"<\"], [/>/g, \">\"], [/\"/g, \"\\\"\"], [/'/g, \"'\"]]; // sanitizes potentially dangerous characters\n\nfunction escape(info, options, escapeOptions, escapeKeys) {\n  var tagIDKeyName = options.tagIDKeyName;\n  var _escapeOptions$doEsca = escapeOptions.doEscape,\n      doEscape = _escapeOptions$doEsca === void 0 ? function (v) {\n    return v;\n  } : _escapeOptions$doEsca;\n  var escaped = {};\n\n  for (var key in info) {\n    var value = info[key]; // no need to escape configuration options\n\n    if (includes(metaInfoOptionKeys, key)) {\n      escaped[key] = value;\n      continue;\n    } // do not use destructuring for disableOptionKeys, it increases transpiled size\n    // due to var checks while we are guaranteed the structure of the cb\n\n\n    var disableKey = disableOptionKeys[0];\n\n    if (escapeOptions[disableKey] && includes(escapeOptions[disableKey], key)) {\n      // this info[key] doesnt need to escaped if the option is listed in __dangerouslyDisableSanitizers\n      escaped[key] = value;\n      continue;\n    }\n\n    var tagId = info[tagIDKeyName];\n\n    if (tagId) {\n      disableKey = disableOptionKeys[1]; // keys which are listed in __dangerouslyDisableSanitizersByTagID for the current vmid do not need to be escaped\n\n      if (escapeOptions[disableKey] && escapeOptions[disableKey][tagId] && includes(escapeOptions[disableKey][tagId], key)) {\n        escaped[key] = value;\n        continue;\n      }\n    }\n\n    if (isString(value)) {\n      escaped[key] = doEscape(value);\n    } else if (isArray(value)) {\n      escaped[key] = value.map(function (v) {\n        if (isPureObject(v)) {\n          return escape(v, options, escapeOptions, true);\n        }\n\n        return doEscape(v);\n      });\n    } else if (isPureObject(value)) {\n      escaped[key] = escape(value, options, escapeOptions, true);\n    } else {\n      escaped[key] = value;\n    }\n\n    if (escapeKeys) {\n      var escapedKey = doEscape(key);\n\n      if (key !== escapedKey) {\n        escaped[escapedKey] = escaped[key];\n        delete escaped[key];\n      }\n    }\n  }\n\n  return escaped;\n}\nfunction escapeMetaInfo(options, info, escapeSequences) {\n  escapeSequences = escapeSequences || []; // do not use destructuring for seq, it increases transpiled size\n  // due to var checks while we are guaranteed the structure of the cb\n\n  var escapeOptions = {\n    doEscape: function doEscape(value) {\n      return escapeSequences.reduce(function (val, seq) {\n        return val.replace(seq[0], seq[1]);\n      }, value);\n    }\n  };\n  disableOptionKeys.forEach(function (disableKey, index) {\n    if (index === 0) {\n      ensureIsArray(info, disableKey);\n    } else if (index === 1) {\n      for (var key in info[disableKey]) {\n        ensureIsArray(info[disableKey], key);\n      }\n    }\n\n    escapeOptions[disableKey] = info[disableKey];\n  }); // begin sanitization\n\n  return escape(info, options, escapeOptions);\n}\n\nfunction applyTemplate(_ref, headObject, template, chunk) {\n  var component = _ref.component,\n      metaTemplateKeyName = _ref.metaTemplateKeyName,\n      contentKeyName = _ref.contentKeyName;\n\n  if (template === true || headObject[metaTemplateKeyName] === true) {\n    // abort, template was already applied\n    return false;\n  }\n\n  if (isUndefined(template) && headObject[metaTemplateKeyName]) {\n    template = headObject[metaTemplateKeyName];\n    headObject[metaTemplateKeyName] = true;\n  } // return early if no template defined\n\n\n  if (!template) {\n    // cleanup faulty template properties\n    delete headObject[metaTemplateKeyName];\n    return false;\n  }\n\n  if (isUndefined(chunk)) {\n    chunk = headObject[contentKeyName];\n  }\n\n  headObject[contentKeyName] = isFunction(template) ? template.call(component, chunk) : template.replace(/%s/g, chunk);\n  return true;\n}\n\nfunction _arrayMerge(_ref, target, source) {\n  var component = _ref.component,\n      tagIDKeyName = _ref.tagIDKeyName,\n      metaTemplateKeyName = _ref.metaTemplateKeyName,\n      contentKeyName = _ref.contentKeyName;\n  // we concat the arrays without merging objects contained in,\n  // but we check for a `vmid` property on each object in the array\n  // using an O(1) lookup associative array exploit\n  var destination = [];\n\n  if (!target.length && !source.length) {\n    return destination;\n  }\n\n  target.forEach(function (targetItem, targetIndex) {\n    // no tagID so no need to check for duplicity\n    if (!targetItem[tagIDKeyName]) {\n      destination.push(targetItem);\n      return;\n    }\n\n    var sourceIndex = findIndex(source, function (item) {\n      return item[tagIDKeyName] === targetItem[tagIDKeyName];\n    });\n    var sourceItem = source[sourceIndex]; // source doesnt contain any duplicate vmid's, we can keep targetItem\n\n    if (sourceIndex === -1) {\n      destination.push(targetItem);\n      return;\n    } // when sourceItem explictly defines contentKeyName or innerHTML as undefined, its\n    // an indication that we need to skip the default behaviour or child has preference over parent\n    // which means we keep the targetItem and ignore/remove the sourceItem\n\n\n    if (contentKeyName in sourceItem && sourceItem[contentKeyName] === undefined || 'innerHTML' in sourceItem && sourceItem.innerHTML === undefined) {\n      destination.push(targetItem); // remove current index from source array so its not concatenated to destination below\n\n      source.splice(sourceIndex, 1);\n      return;\n    } // we now know that targetItem is a duplicate and we should ignore it in favor of sourceItem\n    // if source specifies null as content then ignore both the target as the source\n\n\n    if (sourceItem[contentKeyName] === null || sourceItem.innerHTML === null) {\n      // remove current index from source array so its not concatenated to destination below\n      source.splice(sourceIndex, 1);\n      return;\n    } // now we only need to check if the target has a template to combine it with the source\n\n\n    var targetTemplate = targetItem[metaTemplateKeyName];\n\n    if (!targetTemplate) {\n      return;\n    }\n\n    var sourceTemplate = sourceItem[metaTemplateKeyName];\n\n    if (!sourceTemplate) {\n      // use parent template and child content\n      applyTemplate({\n        component: component,\n        metaTemplateKeyName: metaTemplateKeyName,\n        contentKeyName: contentKeyName\n      }, sourceItem, targetTemplate); // set template to true to indicate template was already applied\n\n      sourceItem.template = true;\n      return;\n    }\n\n    if (!sourceItem[contentKeyName]) {\n      // use parent content and child template\n      applyTemplate({\n        component: component,\n        metaTemplateKeyName: metaTemplateKeyName,\n        contentKeyName: contentKeyName\n      }, sourceItem, undefined, targetItem[contentKeyName]);\n    }\n  });\n  return destination.concat(source);\n}\nvar warningShown = false;\nfunction merge(target, source, options) {\n  options = options || {}; // remove properties explicitly set to false so child components can\n  // optionally _not_ overwrite the parents content\n  // (for array properties this is checked in arrayMerge)\n\n  if (source.title === undefined) {\n    delete source.title;\n  }\n\n  metaInfoAttributeKeys.forEach(function (attrKey) {\n    if (!source[attrKey]) {\n      return;\n    }\n\n    for (var key in source[attrKey]) {\n      if (key in source[attrKey] && source[attrKey][key] === undefined) {\n        if (includes(booleanHtmlAttributes, key) && !warningShown) {\n          warn('VueMeta: Please note that since v2 the value undefined is not used to indicate boolean attributes anymore, see migration guide for details');\n          warningShown = true;\n        }\n\n        delete source[attrKey][key];\n      }\n    }\n  });\n  return deepmerge(target, source, {\n    arrayMerge: function arrayMerge(t, s) {\n      return _arrayMerge(options, t, s);\n    }\n  });\n}\n\nfunction getComponentMetaInfo(options, component) {\n  return getComponentOption(options || {}, component, defaultInfo);\n}\n/**\n * Returns the `opts.option` $option value of the given `opts.component`.\n * If methods are encountered, they will be bound to the component context.\n * If `opts.deep` is true, will recursively merge all child component\n * `opts.option` $option values into the returned result.\n *\n * @param  {Object} opts - options\n * @param  {Object} opts.component - Vue component to fetch option data from\n * @param  {Boolean} opts.deep - look for data in child components as well?\n * @param  {Function} opts.arrayMerge - how should arrays be merged?\n * @param  {String} opts.keyName - the name of the option to look for\n * @param  {Object} [result={}] - result so far\n * @return {Object} result - final aggregated result\n */\n\nfunction getComponentOption(options, component, result) {\n  result = result || {};\n\n  if (component._inactive) {\n    return result;\n  }\n\n  options = options || {};\n  var _options = options,\n      keyName = _options.keyName;\n  var $metaInfo = component.$metaInfo,\n      $options = component.$options,\n      $children = component.$children; // only collect option data if it exists\n\n  if ($options[keyName]) {\n    // if $metaInfo exists then [keyName] was defined as a function\n    // and set to the computed prop $metaInfo in the mixin\n    // using the computed prop should be a small performance increase\n    // because Vue caches those internally\n    var data = $metaInfo || $options[keyName]; // only merge data with result when its an object\n    // eg it could be a function when metaInfo() returns undefined\n    // dueo to the or statement above\n\n    if (isObject(data)) {\n      result = merge(result, data, options);\n    }\n  } // collect & aggregate child options if deep = true\n\n\n  if ($children.length) {\n    $children.forEach(function (childComponent) {\n      // check if the childComponent is in a branch\n      // return otherwise so we dont walk all component branches unnecessarily\n      if (!inMetaInfoBranch(childComponent)) {\n        return;\n      }\n\n      result = getComponentOption(options, childComponent, result);\n    });\n  }\n\n  return result;\n}\n\nvar callbacks = [];\nfunction isDOMComplete(d) {\n  return (d || document).readyState === 'complete';\n}\nfunction addCallback(query, callback) {\n  if (arguments.length === 1) {\n    callback = query;\n    query = '';\n  }\n\n  callbacks.push([query, callback]);\n}\nfunction addCallbacks(_ref, type, tags, autoAddListeners) {\n  var tagIDKeyName = _ref.tagIDKeyName;\n  var hasAsyncCallback = false;\n  tags.forEach(function (tag) {\n    if (!tag[tagIDKeyName] || !tag.callback) {\n      return;\n    }\n\n    hasAsyncCallback = true;\n    addCallback(\"\".concat(type, \"[data-\").concat(tagIDKeyName, \"=\\\"\").concat(tag[tagIDKeyName], \"\\\"]\"), tag.callback);\n  });\n\n  if (!autoAddListeners || !hasAsyncCallback) {\n    return hasAsyncCallback;\n  }\n\n  return addListeners();\n}\nfunction addListeners() {\n  if (isDOMComplete()) {\n    applyCallbacks();\n    return;\n  } // Instead of using a MutationObserver, we just apply\n\n  /* istanbul ignore next */\n\n\n  document.onreadystatechange = function () {\n    applyCallbacks();\n  };\n}\nfunction applyCallbacks(matchElement) {\n  callbacks.forEach(function (args) {\n    // do not use destructuring for args, it increases transpiled size\n    // due to var checks while we are guaranteed the structure of the cb\n    var query = args[0];\n    var callback = args[1];\n    var selector = \"\".concat(query, \"[onload=\\\"this.__vm_l=1\\\"]\");\n    var elements = [];\n\n    if (!matchElement) {\n      elements = toArray(querySelector(selector));\n    }\n\n    if (matchElement && matchElement.matches(selector)) {\n      elements = [matchElement];\n    }\n\n    elements.forEach(function (element) {\n      /* __vm_cb: whether the load callback has been called\n       * __vm_l: set by onload attribute, whether the element was loaded\n       * __vm_ev: whether the event listener was added or not\n       */\n      if (element.__vm_cb) {\n        return;\n      }\n\n      var onload = function onload() {\n        /* Mark that the callback for this element has already been called,\n         * this prevents the callback to run twice in some (rare) conditions\n         */\n        element.__vm_cb = true;\n        /* onload needs to be removed because we only need the\n         * attribute after ssr and if we dont remove it the node\n         * will fail isEqualNode on the client\n         */\n\n        removeAttribute(element, 'onload');\n        callback(element);\n      };\n      /* IE9 doesnt seem to load scripts synchronously,\n       * causing a script sometimes/often already to be loaded\n       * when we add the event listener below (thus adding an onload event\n       * listener has no use because it will never be triggered).\n       * Therefore we add the onload attribute during ssr, and\n       * check here if it was already loaded or not\n       */\n\n\n      if (element.__vm_l) {\n        onload();\n        return;\n      }\n\n      if (!element.__vm_ev) {\n        element.__vm_ev = true;\n        element.addEventListener('load', onload);\n      }\n    });\n  });\n}\n\n// instead of adding it to the html\n\nvar attributeMap = {};\n/**\n * Updates the document's html tag attributes\n *\n * @param  {Object} attrs - the new document html attributes\n * @param  {HTMLElement} tag - the HTMLElement tag to update with new attrs\n */\n\nfunction updateAttribute(appId, options, type, attrs, tag) {\n  var _ref = options || {},\n      attribute = _ref.attribute;\n\n  var vueMetaAttrString = tag.getAttribute(attribute);\n\n  if (vueMetaAttrString) {\n    attributeMap[type] = JSON.parse(decodeURI(vueMetaAttrString));\n    removeAttribute(tag, attribute);\n  }\n\n  var data = attributeMap[type] || {};\n  var toUpdate = []; // remove attributes from the map\n  // which have been removed for this appId\n\n  for (var attr in data) {\n    if (data[attr] !== undefined && appId in data[attr]) {\n      toUpdate.push(attr);\n\n      if (!attrs[attr]) {\n        delete data[attr][appId];\n      }\n    }\n  }\n\n  for (var _attr in attrs) {\n    var attrData = data[_attr];\n\n    if (!attrData || attrData[appId] !== attrs[_attr]) {\n      toUpdate.push(_attr);\n\n      if (attrs[_attr] !== undefined) {\n        data[_attr] = data[_attr] || {};\n        data[_attr][appId] = attrs[_attr];\n      }\n    }\n  }\n\n  for (var _i = 0, _toUpdate = toUpdate; _i < _toUpdate.length; _i++) {\n    var _attr2 = _toUpdate[_i];\n    var _attrData = data[_attr2];\n    var attrValues = [];\n\n    for (var _appId in _attrData) {\n      Array.prototype.push.apply(attrValues, [].concat(_attrData[_appId]));\n    }\n\n    if (attrValues.length) {\n      var attrValue = includes(booleanHtmlAttributes, _attr2) && attrValues.some(Boolean) ? '' : attrValues.filter(function (v) {\n        return v !== undefined;\n      }).join(' ');\n      tag.setAttribute(_attr2, attrValue);\n    } else {\n      removeAttribute(tag, _attr2);\n    }\n  }\n\n  attributeMap[type] = data;\n}\n\n/**\n * Updates the document title\n *\n * @param  {String} title - the new title of the document\n */\nfunction updateTitle(title) {\n  if (!title && title !== '') {\n    return;\n  }\n\n  document.title = title;\n}\n\n/**\n * Updates meta tags inside <head> and <body> on the client. Borrowed from `react-helmet`:\n * https://github.com/nfl/react-helmet/blob/004d448f8de5f823d10f838b02317521180f34da/src/Helmet.js#L195-L245\n *\n * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} type - the name of the tag\n * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n * @return {Object} - a representation of what tags changed\n */\n\nfunction updateTag(appId, options, type, tags, head, body) {\n  var _ref = options || {},\n      attribute = _ref.attribute,\n      tagIDKeyName = _ref.tagIDKeyName;\n\n  var dataAttributes = commonDataAttributes.slice();\n  dataAttributes.push(tagIDKeyName);\n  var newElements = [];\n  var queryOptions = {\n    appId: appId,\n    attribute: attribute,\n    type: type,\n    tagIDKeyName: tagIDKeyName\n  };\n  var currentElements = {\n    head: queryElements(head, queryOptions),\n    pbody: queryElements(body, queryOptions, {\n      pbody: true\n    }),\n    body: queryElements(body, queryOptions, {\n      body: true\n    })\n  };\n\n  if (tags.length > 1) {\n    // remove duplicates that could have been found by merging tags\n    // which include a mixin with metaInfo and that mixin is used\n    // by multiple components on the same page\n    var found = [];\n    tags = tags.filter(function (x) {\n      var k = JSON.stringify(x);\n      var res = !includes(found, k);\n      found.push(k);\n      return res;\n    });\n  }\n\n  tags.forEach(function (tag) {\n    if (tag.skip) {\n      return;\n    }\n\n    var newElement = document.createElement(type);\n\n    if (!tag.once) {\n      newElement.setAttribute(attribute, appId);\n    }\n\n    Object.keys(tag).forEach(function (attr) {\n      /* istanbul ignore next */\n      if (includes(tagProperties, attr)) {\n        return;\n      }\n\n      if (attr === 'innerHTML') {\n        newElement.innerHTML = tag.innerHTML;\n        return;\n      }\n\n      if (attr === 'json') {\n        newElement.innerHTML = JSON.stringify(tag.json);\n        return;\n      }\n\n      if (attr === 'cssText') {\n        if (newElement.styleSheet) {\n          /* istanbul ignore next */\n          newElement.styleSheet.cssText = tag.cssText;\n        } else {\n          newElement.appendChild(document.createTextNode(tag.cssText));\n        }\n\n        return;\n      }\n\n      if (attr === 'callback') {\n        newElement.onload = function () {\n          return tag[attr](newElement);\n        };\n\n        return;\n      }\n\n      var _attr = includes(dataAttributes, attr) ? \"data-\".concat(attr) : attr;\n\n      var isBooleanAttribute = includes(booleanHtmlAttributes, attr);\n\n      if (isBooleanAttribute && !tag[attr]) {\n        return;\n      }\n\n      var value = isBooleanAttribute ? '' : tag[attr];\n      newElement.setAttribute(_attr, value);\n    });\n    var oldElements = currentElements[getElementsKey(tag)]; // Remove a duplicate tag from domTagstoRemove, so it isn't cleared.\n\n    var indexToDelete;\n    var hasEqualElement = oldElements.some(function (existingTag, index) {\n      indexToDelete = index;\n      return newElement.isEqualNode(existingTag);\n    });\n\n    if (hasEqualElement && (indexToDelete || indexToDelete === 0)) {\n      oldElements.splice(indexToDelete, 1);\n    } else {\n      newElements.push(newElement);\n    }\n  });\n  var oldElements = [];\n\n  for (var _type in currentElements) {\n    Array.prototype.push.apply(oldElements, currentElements[_type]);\n  } // remove old elements\n\n\n  oldElements.forEach(function (element) {\n    element.parentNode.removeChild(element);\n  }); // insert new elements\n\n  newElements.forEach(function (element) {\n    if (element.hasAttribute('data-body')) {\n      body.appendChild(element);\n      return;\n    }\n\n    if (element.hasAttribute('data-pbody')) {\n      body.insertBefore(element, body.firstChild);\n      return;\n    }\n\n    head.appendChild(element);\n  });\n  return {\n    oldTags: oldElements,\n    newTags: newElements\n  };\n}\n\n/**\n * Performs client-side updates when new meta info is received\n *\n * @param  {Object} newInfo - the meta info to update to\n */\n\nfunction updateClientMetaInfo(appId, options, newInfo) {\n  options = options || {};\n  var _options = options,\n      ssrAttribute = _options.ssrAttribute,\n      ssrAppId = _options.ssrAppId; // only cache tags for current update\n\n  var tags = {};\n  var htmlTag = getTag(tags, 'html'); // if this is a server render, then dont update\n\n  if (appId === ssrAppId && htmlTag.hasAttribute(ssrAttribute)) {\n    // remove the server render attribute so we can update on (next) changes\n    removeAttribute(htmlTag, ssrAttribute); // add load callbacks if the\n\n    var addLoadListeners = false;\n    tagsSupportingOnload.forEach(function (type) {\n      if (newInfo[type] && addCallbacks(options, type, newInfo[type])) {\n        addLoadListeners = true;\n      }\n    });\n\n    if (addLoadListeners) {\n      addListeners();\n    }\n\n    return false;\n  } // initialize tracked changes\n\n\n  var tagsAdded = {};\n  var tagsRemoved = {};\n\n  for (var type in newInfo) {\n    // ignore these\n    if (includes(metaInfoOptionKeys, type)) {\n      continue;\n    }\n\n    if (type === 'title') {\n      // update the title\n      updateTitle(newInfo.title);\n      continue;\n    }\n\n    if (includes(metaInfoAttributeKeys, type)) {\n      var tagName = type.substr(0, 4);\n      updateAttribute(appId, options, type, newInfo[type], getTag(tags, tagName));\n      continue;\n    } // tags should always be an array, ignore if it isnt\n\n\n    if (!isArray(newInfo[type])) {\n      continue;\n    }\n\n    var _updateTag = updateTag(appId, options, type, newInfo[type], getTag(tags, 'head'), getTag(tags, 'body')),\n        oldTags = _updateTag.oldTags,\n        newTags = _updateTag.newTags;\n\n    if (newTags.length) {\n      tagsAdded[type] = newTags;\n      tagsRemoved[type] = oldTags;\n    }\n  }\n\n  return {\n    tagsAdded: tagsAdded,\n    tagsRemoved: tagsRemoved\n  };\n}\n\nvar appsMetaInfo;\nfunction addApp(rootVm, appId, options) {\n  return {\n    set: function set(metaInfo) {\n      return setMetaInfo(rootVm, appId, options, metaInfo);\n    },\n    remove: function remove() {\n      return removeMetaInfo(rootVm, appId, options);\n    }\n  };\n}\nfunction setMetaInfo(rootVm, appId, options, metaInfo) {\n  // if a vm exists _and_ its mounted then immediately update\n  if (rootVm && rootVm.$el) {\n    return updateClientMetaInfo(appId, options, metaInfo);\n  } // store for later, the info\n  // will be set on the first refresh\n\n\n  appsMetaInfo = appsMetaInfo || {};\n  appsMetaInfo[appId] = metaInfo;\n}\nfunction removeMetaInfo(rootVm, appId, options) {\n  if (rootVm && rootVm.$el) {\n    var tags = {};\n\n    var _iterator = _createForOfIteratorHelper(metaInfoAttributeKeys),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var type = _step.value;\n        var tagName = type.substr(0, 4);\n        updateAttribute(appId, options, type, {}, getTag(tags, tagName));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return removeElementsByAppId(options, appId);\n  }\n\n  if (appsMetaInfo[appId]) {\n    delete appsMetaInfo[appId];\n    clearAppsMetaInfo();\n  }\n}\nfunction getAppsMetaInfo() {\n  return appsMetaInfo;\n}\nfunction clearAppsMetaInfo(force) {\n  if (force || !Object.keys(appsMetaInfo).length) {\n    appsMetaInfo = undefined;\n  }\n}\n\n/**\n * Returns the correct meta info for the given component\n * (child components will overwrite parent meta info)\n *\n * @param  {Object} component - the Vue instance to get meta info from\n * @return {Object} - returned meta info\n */\n\nfunction getMetaInfo(options, info, escapeSequences, component) {\n  options = options || {};\n  escapeSequences = escapeSequences || [];\n  var _options = options,\n      tagIDKeyName = _options.tagIDKeyName; // Remove all \"template\" tags from meta\n  // backup the title chunk in case user wants access to it\n\n  if (info.title) {\n    info.titleChunk = info.title;\n  } // replace title with populated template\n\n\n  if (info.titleTemplate && info.titleTemplate !== '%s') {\n    applyTemplate({\n      component: component,\n      contentKeyName: 'title'\n    }, info, info.titleTemplate, info.titleChunk || '');\n  } // convert base tag to an array so it can be handled the same way\n  // as the other tags\n\n\n  if (info.base) {\n    info.base = Object.keys(info.base).length ? [info.base] : [];\n  }\n\n  if (info.meta) {\n    // remove meta items with duplicate vmid's\n    info.meta = info.meta.filter(function (metaItem, index, arr) {\n      var hasVmid = !!metaItem[tagIDKeyName];\n\n      if (!hasVmid) {\n        return true;\n      }\n\n      var isFirstItemForVmid = index === findIndex(arr, function (item) {\n        return item[tagIDKeyName] === metaItem[tagIDKeyName];\n      });\n      return isFirstItemForVmid;\n    }); // apply templates if needed\n\n    info.meta.forEach(function (metaObject) {\n      return applyTemplate(options, metaObject);\n    });\n  }\n\n  return escapeMetaInfo(options, info, escapeSequences);\n}\n\n/**\n * When called, will update the current meta info with new meta info.\n * Useful when updating meta info as the result of an asynchronous\n * action that resolves after the initial render takes place.\n *\n * Credit to [SÃ©bastien Chopin](https://github.com/Atinux) for the suggestion\n * to implement this method.\n *\n * @return {Object} - new meta info\n */\n\nfunction refresh(rootVm, options) {\n  options = options || {}; // make sure vue-meta was initiated\n\n  if (!rootVm[rootConfigKey]) {\n    showWarningNotSupported();\n    return {};\n  } // collect & aggregate all metaInfo $options\n\n\n  var rawInfo = getComponentMetaInfo(options, rootVm);\n  var metaInfo = getMetaInfo(options, rawInfo, clientSequences, rootVm);\n  var appId = rootVm[rootConfigKey].appId;\n  var tags = updateClientMetaInfo(appId, options, metaInfo); // emit \"event\" with new info\n\n  if (tags && isFunction(metaInfo.changed)) {\n    metaInfo.changed(metaInfo, tags.tagsAdded, tags.tagsRemoved);\n    tags = {\n      addedTags: tags.tagsAdded,\n      removedTags: tags.tagsRemoved\n    };\n  }\n\n  var appsMetaInfo = getAppsMetaInfo();\n\n  if (appsMetaInfo) {\n    for (var additionalAppId in appsMetaInfo) {\n      updateClientMetaInfo(additionalAppId, options, appsMetaInfo[additionalAppId]);\n      delete appsMetaInfo[additionalAppId];\n    }\n\n    clearAppsMetaInfo(true);\n  }\n\n  return {\n    vm: rootVm,\n    metaInfo: metaInfo,\n    // eslint-disable-line object-shorthand\n    tags: tags\n  };\n}\n\n/**\n * Generates tag attributes for use on the server.\n *\n * @param  {('bodyAttrs'|'htmlAttrs'|'headAttrs')} type - the type of attributes to generate\n * @param  {Object} data - the attributes to generate\n * @return {Object} - the attribute generator\n */\n\nfunction attributeGenerator(options, type, data, _ref) {\n  var addSsrAttribute = _ref.addSsrAttribute;\n\n  var _ref2 = options || {},\n      attribute = _ref2.attribute,\n      ssrAttribute = _ref2.ssrAttribute;\n\n  var attributeStr = '';\n\n  for (var attr in data) {\n    var attrData = data[attr];\n    var attrValues = [];\n\n    for (var appId in attrData) {\n      attrValues.push.apply(attrValues, _toConsumableArray([].concat(attrData[appId])));\n    }\n\n    if (attrValues.length) {\n      attributeStr += booleanHtmlAttributes.includes(attr) && attrValues.some(Boolean) ? \"\".concat(attr) : \"\".concat(attr, \"=\\\"\").concat(attrValues.join(' '), \"\\\"\");\n      attributeStr += ' ';\n    }\n  }\n\n  if (attributeStr) {\n    attributeStr += \"\".concat(attribute, \"=\\\"\").concat(encodeURI(JSON.stringify(data)), \"\\\"\");\n  }\n\n  if (type === 'htmlAttrs' && addSsrAttribute) {\n    return \"\".concat(ssrAttribute).concat(attributeStr ? ' ' : '').concat(attributeStr);\n  }\n\n  return attributeStr;\n}\n\n/**\n * Generates title output for the server\n *\n * @param  {'title'} type - the string \"title\"\n * @param  {String} data - the title text\n * @return {Object} - the title generator\n */\nfunction titleGenerator(options, type, data, generatorOptions) {\n  var _ref = generatorOptions || {},\n      ln = _ref.ln;\n\n  if (!data) {\n    return '';\n  }\n\n  return \"<\".concat(type, \">\").concat(data, \"</\").concat(type, \">\").concat(ln ? '\\n' : '');\n}\n\n/**\n * Generates meta, base, link, style, script, noscript tags for use on the server\n *\n * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} the name of the tag\n * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n * @return {Object} - the tag generator\n */\n\nfunction tagGenerator(options, type, tags, generatorOptions) {\n  var _ref = options || {},\n      ssrAppId = _ref.ssrAppId,\n      attribute = _ref.attribute,\n      tagIDKeyName = _ref.tagIDKeyName;\n\n  var _ref2 = generatorOptions || {},\n      appId = _ref2.appId,\n      _ref2$isSSR = _ref2.isSSR,\n      isSSR = _ref2$isSSR === void 0 ? true : _ref2$isSSR,\n      _ref2$body = _ref2.body,\n      body = _ref2$body === void 0 ? false : _ref2$body,\n      _ref2$pbody = _ref2.pbody,\n      pbody = _ref2$pbody === void 0 ? false : _ref2$pbody,\n      _ref2$ln = _ref2.ln,\n      ln = _ref2$ln === void 0 ? false : _ref2$ln;\n\n  var dataAttributes = [tagIDKeyName].concat(_toConsumableArray(commonDataAttributes));\n\n  if (!tags || !tags.length) {\n    return '';\n  } // build a string containing all tags of this type\n\n\n  return tags.reduce(function (tagsStr, tag) {\n    if (tag.skip) {\n      return tagsStr;\n    }\n\n    var tagKeys = Object.keys(tag);\n\n    if (tagKeys.length === 0) {\n      return tagsStr; // Bail on empty tag object\n    }\n\n    if (Boolean(tag.body) !== body || Boolean(tag.pbody) !== pbody) {\n      return tagsStr;\n    }\n\n    var attrs = tag.once ? '' : \" \".concat(attribute, \"=\\\"\").concat(appId || (isSSR === false ? '1' : ssrAppId), \"\\\"\"); // build a string containing all attributes of this tag\n\n    for (var attr in tag) {\n      // these attributes are treated as children on the tag\n      if (tagAttributeAsInnerContent.includes(attr) || tagProperties.includes(attr)) {\n        continue;\n      }\n\n      if (attr === 'callback') {\n        attrs += ' onload=\"this.__vm_l=1\"';\n        continue;\n      } // these form the attribute list for this tag\n\n\n      var prefix = '';\n\n      if (dataAttributes.includes(attr)) {\n        prefix = 'data-';\n      }\n\n      var isBooleanAttr = !prefix && booleanHtmlAttributes.includes(attr);\n\n      if (isBooleanAttr && !tag[attr]) {\n        continue;\n      }\n\n      attrs += \" \".concat(prefix).concat(attr) + (isBooleanAttr ? '' : \"=\\\"\".concat(tag[attr], \"\\\"\"));\n    }\n\n    var json = '';\n\n    if (tag.json) {\n      json = JSON.stringify(tag.json);\n    } // grab child content from one of these attributes, if possible\n\n\n    var content = tag.innerHTML || tag.cssText || json; // generate tag exactly without any other redundant attribute\n    // these tags have no end tag\n\n    var hasEndTag = !tagsWithoutEndTag.includes(type); // these tag types will have content inserted\n\n    var hasContent = hasEndTag && tagsWithInnerContent.includes(type); // the final string for this specific tag\n\n    return \"\".concat(tagsStr, \"<\").concat(type).concat(attrs).concat(!hasContent && hasEndTag ? '/' : '', \">\") + (hasContent ? \"\".concat(content, \"</\").concat(type, \">\") : '') + (ln ? '\\n' : '');\n  }, '');\n}\n\n/**\n * Converts a meta info property to one that can be stringified on the server\n *\n * @param  {String} type - the type of data to convert\n * @param  {(String|Object|Array<Object>)} data - the data value\n * @return {Object} - the new injector\n */\n\nfunction generateServerInjector(options, metaInfo, globalInjectOptions) {\n  var serverInjector = {\n    data: metaInfo,\n    extraData: undefined,\n    addInfo: function addInfo(appId, metaInfo) {\n      this.extraData = this.extraData || {};\n      this.extraData[appId] = metaInfo;\n    },\n    callInjectors: function callInjectors(opts) {\n      var m = this.injectors; // only call title for the head\n\n      return (opts.body || opts.pbody ? '' : m.title.text(opts)) + m.meta.text(opts) + m.base.text(opts) + m.link.text(opts) + m.style.text(opts) + m.script.text(opts) + m.noscript.text(opts);\n    },\n    injectors: {\n      head: function head(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln\n        }));\n      },\n      bodyPrepend: function bodyPrepend(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln,\n          pbody: true\n        }));\n      },\n      bodyAppend: function bodyAppend(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln,\n          body: true\n        }));\n      }\n    }\n  };\n\n  var _loop = function _loop(type) {\n    if (metaInfoOptionKeys.includes(type)) {\n      return \"continue\";\n    }\n\n    serverInjector.injectors[type] = {\n      text: function text(injectOptions) {\n        var addSsrAttribute = injectOptions === true;\n        injectOptions = _objectSpread2(_objectSpread2({\n          addSsrAttribute: addSsrAttribute\n        }, globalInjectOptions), injectOptions);\n\n        if (type === 'title') {\n          return titleGenerator(options, type, serverInjector.data[type], injectOptions);\n        }\n\n        if (metaInfoAttributeKeys.includes(type)) {\n          var attributeData = {};\n          var data = serverInjector.data[type];\n\n          if (data) {\n            var appId = injectOptions.isSSR === false ? '1' : options.ssrAppId;\n\n            for (var attr in data) {\n              attributeData[attr] = _defineProperty({}, appId, data[attr]);\n            }\n          }\n\n          if (serverInjector.extraData) {\n            for (var _appId in serverInjector.extraData) {\n              var _data = serverInjector.extraData[_appId][type];\n\n              if (_data) {\n                for (var _attr in _data) {\n                  attributeData[_attr] = _objectSpread2(_objectSpread2({}, attributeData[_attr]), {}, _defineProperty({}, _appId, _data[_attr]));\n                }\n              }\n            }\n          }\n\n          return attributeGenerator(options, type, attributeData, injectOptions);\n        }\n\n        var str = tagGenerator(options, type, serverInjector.data[type], injectOptions);\n\n        if (serverInjector.extraData) {\n          for (var _appId2 in serverInjector.extraData) {\n            var _data2 = serverInjector.extraData[_appId2][type];\n            var extraStr = tagGenerator(options, type, _data2, _objectSpread2({\n              appId: _appId2\n            }, injectOptions));\n            str = \"\".concat(str).concat(extraStr);\n          }\n        }\n\n        return str;\n      }\n    };\n  };\n\n  for (var type in defaultInfo) {\n    var _ret = _loop(type);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return serverInjector;\n}\n\n/**\n * Converts the state of the meta info object such that each item\n * can be compiled to a tag string on the server\n *\n * @vm {Object} - Vue instance - ideally the root component\n * @return {Object} - server meta info with `toString` methods\n */\n\nfunction inject(rootVm, options, injectOptions) {\n  // make sure vue-meta was initiated\n  if (!rootVm[rootConfigKey]) {\n    showWarningNotSupported();\n    return {};\n  } // collect & aggregate all metaInfo $options\n\n\n  var rawInfo = getComponentMetaInfo(options, rootVm);\n  var metaInfo = getMetaInfo(options, rawInfo, serverSequences, rootVm); // generate server injector\n\n  var serverInjector = generateServerInjector(options, metaInfo, injectOptions); // add meta info from additional apps\n\n  var appsMetaInfo = getAppsMetaInfo();\n\n  if (appsMetaInfo) {\n    for (var additionalAppId in appsMetaInfo) {\n      serverInjector.addInfo(additionalAppId, appsMetaInfo[additionalAppId]);\n      delete appsMetaInfo[additionalAppId];\n    }\n\n    clearAppsMetaInfo(true);\n  }\n\n  return serverInjector.injectors;\n}\n\nfunction $meta(options) {\n  options = options || {};\n  /**\n   * Returns an injector for server-side rendering.\n   * @this {Object} - the Vue instance (a root component)\n   * @return {Object} - injector\n   */\n\n  var $root = this.$root;\n  return {\n    getOptions: function getOptions$1() {\n      return getOptions(options);\n    },\n    setOptions: function setOptions(newOptions) {\n      var refreshNavKey = 'refreshOnceOnNavigation';\n\n      if (newOptions && newOptions[refreshNavKey]) {\n        options.refreshOnceOnNavigation = !!newOptions[refreshNavKey];\n        addNavGuards($root);\n      }\n\n      var debounceWaitKey = 'debounceWait';\n\n      if (newOptions && debounceWaitKey in newOptions) {\n        var debounceWait = parseInt(newOptions[debounceWaitKey]);\n\n        if (!isNaN(debounceWait)) {\n          options.debounceWait = debounceWait;\n        }\n      }\n\n      var waitOnDestroyedKey = 'waitOnDestroyed';\n\n      if (newOptions && waitOnDestroyedKey in newOptions) {\n        options.waitOnDestroyed = !!newOptions[waitOnDestroyedKey];\n      }\n    },\n    refresh: function refresh$1() {\n      return refresh($root, options);\n    },\n    inject: function inject$1(injectOptions) {\n      return  inject($root, options, injectOptions) ;\n    },\n    pause: function pause$1() {\n      return pause($root);\n    },\n    resume: function resume$1() {\n      return resume($root);\n    },\n    addApp: function addApp$1(appId) {\n      return addApp($root, appId, options);\n    }\n  };\n}\n\nfunction generate(rawInfo, options) {\n  options = setOptions(options);\n  var metaInfo = getMetaInfo(options, rawInfo, serverSequences);\n  var serverInjector = generateServerInjector(options, metaInfo);\n  return serverInjector.injectors;\n}\n\n/**\n * Plugin install function.\n * @param {Function} Vue - the Vue constructor.\n */\n\nfunction install(Vue, options) {\n  if (Vue.__vuemeta_installed) {\n    return;\n  }\n\n  Vue.__vuemeta_installed = true;\n  options = setOptions(options);\n\n  Vue.prototype.$meta = function () {\n    return $meta.call(this, options);\n  };\n\n  Vue.mixin(createMixin(Vue, options));\n}\n\nvar index = {\n  version: version,\n  install: install,\n  generate: function generate$1(metaInfo, options) {\n    return  generate(metaInfo, options) ;\n  },\n  hasMetaInfo: hasMetaInfo\n};\n\nexport default index;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}